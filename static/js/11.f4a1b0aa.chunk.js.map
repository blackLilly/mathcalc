{"version":3,"sources":["../node_modules/@material-ui/icons/NavigateNext.js","../node_modules/@material-ui/core/esm/internal/svg-icons/MoreHoriz.js","../node_modules/@material-ui/core/esm/Breadcrumbs/BreadcrumbCollapsed.js","../node_modules/@material-ui/core/esm/Breadcrumbs/Breadcrumbs.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js","../../node_modules/uzip/UZIP.js","../../lib/UPNG.js","../../lib/utils.js","../../lib/image-compression.js","../../lib/web-worker.js","../../lib/index.js","../node_modules/@material-ui/icons/InsertPhoto.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","Object","defineProperty","exports","value","default","React","_default","createElement","d","createSvgIcon","withStyles","theme","root","display","marginLeft","spacing","marginRight","backgroundColor","palette","grey","color","borderRadius","cursor","boxShadow","shadows","emphasize","icon","width","height","name","props","classes","other","_objectWithoutProperties","ButtonBase","_extends","component","className","focusRipple","MoreHorizIcon","Breadcrumbs","ref","children","_props$component","Component","_props$expandText","expandText","_props$itemsAfterColl","itemsAfterCollapse","_props$itemsBeforeCol","itemsBeforeCollapse","_props$maxItems","maxItems","_props$separator","separator","_React$useState","expanded","setExpanded","allItems","toArray","filter","child","map","index","li","key","concat","Typography","clsx","ol","items","reduce","acc","current","length","push","insertSeparators","_toConsumableArray","slice","BreadcrumbCollapsed","onClick","event","focusable","currentTarget","parentNode","querySelector","focus","renderItemsBeforeAndAfter","flexWrap","alignItems","padding","margin","listStyle","userSelect","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","descriptor","enumerable","configurable","writable","_createClass","protoProps","staticProps","prototype","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","_assertThisInitialized","self","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","create","constructor","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","call","e","_typeof","obj","Symbol","iterator","_possibleConstructorReturn","assertThisInitialized","_createSuper","Derived","hasNativeReflectConstruct","isNativeReflectConstruct","result","Super","NewTarget","this","arguments","apply","UZIP","eocd","rUi","cnu","csize","data","out","readUshort","cmpr","nlen","elen","file","opts","buf","crc","off","wUi","noCmpr","cpr","tot","U","t","usize","tab","k","c","b","end","eend","a","buff","l","s","strl","str","code","ci","lvl","len","dlen","strt","prev","lc","cvrd","Math","lgi","lits","dst","dgi","pos","dif","td","j","ei","curd","MD","putsF","_putsF","BTYPE","o0","ltree","fltree","putsE","itree","qc","si","p8","dset","numh","ML","MH","numl","tree","set","nxt","nnxt","lz","MAXL","hst","tl","hl","list","l2","i2","f","i0","maxl","dbt","ch","u8","F","_bitsF","bitsE","noBuf","HLIT","dmap","mx0","dtree","dlit","dcode","dbs","nbuf","lmap","_bitsE","n","mx","max_code","MAX_BITS","next_code","rest","i1","r15","val","dt","x","tgt","sv","pushV","h","w","frm","fw","fdata","UPNG","frms","ctype","qarea","area","ti","tr","ts","tb","y","s0","bpl","qi","t0","gr","type","dd","fr","rect","delay","fd","bin","offset","nz","bfr","text","rUs","interlace","N","H","W","X","Q","v","S","A","q","D","R","V","Z","m","I","J","K","_","ri","pass","sh","sw","starting_row","starting_col","row","cdi","col","bpp","ii","pa","pb","pc","_bin","ns","decodeURIComponent","sb","tw","oa","ioa","fg","fa","nimg","bufs","dl","leng","cimg","anim","wUs","prms","evenCrd","ilen","img","plte","inds","nbufs","abuf","cof","qres","img32","cmc","depth","it","mix","max","miy","may","sarea","tarea","nx","nw","r","miY","cimg32","cy","ftry","di","g","nd","planeDst","bst","ps","maxL","err","node","ln","rn","leafs","node1","vecDot","m1","m2","m0","M4","m3","Cov","M","il","isBrowser","reader","getFilefromDataUrl","dataUrl","arr","bstr","getImageData","fileName","tags","view","canvas","maxWidthOrHeight","ctx","newCanvas","drawFileInCanvas","cnt","imageCompressionLibUrl","script","parse","createSourceObject","imageCompression"],"mappings":"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","file":"static/js/11.f4a1b0aa.chunk.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"\n}), 'NavigateNext');\n\nexports.default = _default;","import * as React from 'react';\nimport createSvgIcon from '../../utils/createSvgIcon';\n/**\n * @ignore - internal component.\n */\n\nexport default createSvgIcon( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z\"\n}), 'MoreHoriz');","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport withStyles from '../styles/withStyles';\nimport { emphasize } from '../styles/colorManipulator';\nimport MoreHorizIcon from '../internal/svg-icons/MoreHoriz';\nimport ButtonBase from '../ButtonBase';\n\nvar styles = function styles(theme) {\n  return {\n    root: {\n      display: 'flex',\n      marginLeft: theme.spacing(0.5),\n      marginRight: theme.spacing(0.5),\n      backgroundColor: theme.palette.grey[100],\n      color: theme.palette.grey[700],\n      borderRadius: 2,\n      cursor: 'pointer',\n      '&:hover, &:focus': {\n        backgroundColor: theme.palette.grey[200]\n      },\n      '&:active': {\n        boxShadow: theme.shadows[0],\n        backgroundColor: emphasize(theme.palette.grey[200], 0.12)\n      }\n    },\n    icon: {\n      width: 24,\n      height: 16\n    }\n  };\n};\n/**\n * @ignore - internal component.\n */\n\n\nfunction BreadcrumbCollapsed(props) {\n  var classes = props.classes,\n      other = _objectWithoutProperties(props, [\"classes\"]);\n\n  return /*#__PURE__*/React.createElement(ButtonBase, _extends({\n    component: \"li\",\n    className: classes.root,\n    focusRipple: true\n  }, other), /*#__PURE__*/React.createElement(MoreHorizIcon, {\n    className: classes.icon\n  }));\n}\n\nprocess.env.NODE_ENV !== \"production\" ? BreadcrumbCollapsed.propTypes = {\n  /**\n   * @ignore\n   */\n  classes: PropTypes.object.isRequired\n} : void 0;\nexport default withStyles(styles, {\n  name: 'PrivateBreadcrumbCollapsed'\n})(BreadcrumbCollapsed);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport withStyles from '../styles/withStyles';\nimport Typography from '../Typography';\nimport BreadcrumbCollapsed from './BreadcrumbCollapsed';\nexport var styles = {\n  /* Styles applied to the root element. */\n  root: {},\n\n  /* Styles applied to the ol element. */\n  ol: {\n    display: 'flex',\n    flexWrap: 'wrap',\n    alignItems: 'center',\n    padding: 0,\n    margin: 0,\n    listStyle: 'none'\n  },\n\n  /* Styles applied to the li element. */\n  li: {},\n\n  /* Styles applied to the separator element. */\n  separator: {\n    display: 'flex',\n    userSelect: 'none',\n    marginLeft: 8,\n    marginRight: 8\n  }\n};\n\nfunction insertSeparators(items, className, separator) {\n  return items.reduce(function (acc, current, index) {\n    if (index < items.length - 1) {\n      acc = acc.concat(current, /*#__PURE__*/React.createElement(\"li\", {\n        \"aria-hidden\": true,\n        key: \"separator-\".concat(index),\n        className: className\n      }, separator));\n    } else {\n      acc.push(current);\n    }\n\n    return acc;\n  }, []);\n}\n\nvar Breadcrumbs = /*#__PURE__*/React.forwardRef(function Breadcrumbs(props, ref) {\n  var children = props.children,\n      classes = props.classes,\n      className = props.className,\n      _props$component = props.component,\n      Component = _props$component === void 0 ? 'nav' : _props$component,\n      _props$expandText = props.expandText,\n      expandText = _props$expandText === void 0 ? 'Show path' : _props$expandText,\n      _props$itemsAfterColl = props.itemsAfterCollapse,\n      itemsAfterCollapse = _props$itemsAfterColl === void 0 ? 1 : _props$itemsAfterColl,\n      _props$itemsBeforeCol = props.itemsBeforeCollapse,\n      itemsBeforeCollapse = _props$itemsBeforeCol === void 0 ? 1 : _props$itemsBeforeCol,\n      _props$maxItems = props.maxItems,\n      maxItems = _props$maxItems === void 0 ? 8 : _props$maxItems,\n      _props$separator = props.separator,\n      separator = _props$separator === void 0 ? '/' : _props$separator,\n      other = _objectWithoutProperties(props, [\"children\", \"classes\", \"className\", \"component\", \"expandText\", \"itemsAfterCollapse\", \"itemsBeforeCollapse\", \"maxItems\", \"separator\"]);\n\n  var _React$useState = React.useState(false),\n      expanded = _React$useState[0],\n      setExpanded = _React$useState[1];\n\n  var renderItemsBeforeAndAfter = function renderItemsBeforeAndAfter(allItems) {\n    var handleClickExpand = function handleClickExpand(event) {\n      setExpanded(true); // The clicked element received the focus but gets removed from the DOM.\n      // Let's keep the focus in the component after expanding.\n\n      var focusable = event.currentTarget.parentNode.querySelector('a[href],button,[tabindex]');\n\n      if (focusable) {\n        focusable.focus();\n      }\n    }; // This defends against someone passing weird input, to ensure that if all\n    // items would be shown anyway, we just show all items without the EllipsisItem\n\n\n    if (itemsBeforeCollapse + itemsAfterCollapse >= allItems.length) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.error(['Material-UI: You have provided an invalid combination of props to the Breadcrumbs.', \"itemsAfterCollapse={\".concat(itemsAfterCollapse, \"} + itemsBeforeCollapse={\").concat(itemsBeforeCollapse, \"} >= maxItems={\").concat(maxItems, \"}\")].join('\\n'));\n      }\n\n      return allItems;\n    }\n\n    return [].concat(_toConsumableArray(allItems.slice(0, itemsBeforeCollapse)), [/*#__PURE__*/React.createElement(BreadcrumbCollapsed, {\n      \"aria-label\": expandText,\n      key: \"ellipsis\",\n      onClick: handleClickExpand\n    })], _toConsumableArray(allItems.slice(allItems.length - itemsAfterCollapse, allItems.length)));\n  };\n\n  var allItems = React.Children.toArray(children).filter(function (child) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"Material-UI: The Breadcrumbs component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n\n    return /*#__PURE__*/React.isValidElement(child);\n  }).map(function (child, index) {\n    return /*#__PURE__*/React.createElement(\"li\", {\n      className: classes.li,\n      key: \"child-\".concat(index)\n    }, child);\n  });\n  return /*#__PURE__*/React.createElement(Typography, _extends({\n    ref: ref,\n    component: Component,\n    color: \"textSecondary\",\n    className: clsx(classes.root, className)\n  }, other), /*#__PURE__*/React.createElement(\"ol\", {\n    className: classes.ol\n  }, insertSeparators(expanded || maxItems && allItems.length <= maxItems ? allItems : renderItemsBeforeAndAfter(allItems), classes.separator, separator)));\n});\nprocess.env.NODE_ENV !== \"production\" ? Breadcrumbs.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The breadcrumb children.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   * See [CSS API](#css) below for more details.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes\n  /* @typescript-to-proptypes-ignore */\n  .elementType,\n\n  /**\n   * Override the default label for the expand button.\n   *\n   * For localization purposes, you can use the provided [translations](/guides/localization/).\n   */\n  expandText: PropTypes.string,\n\n  /**\n   * If max items is exceeded, the number of items to show after the ellipsis.\n   */\n  itemsAfterCollapse: PropTypes.number,\n\n  /**\n   * If max items is exceeded, the number of items to show before the ellipsis.\n   */\n  itemsBeforeCollapse: PropTypes.number,\n\n  /**\n   * Specifies the maximum number of breadcrumbs to display. When there are more\n   * than the maximum number, only the first `itemsBeforeCollapse` and last `itemsAfterCollapse`\n   * will be shown, with an ellipsis in between.\n   */\n  maxItems: PropTypes.number,\n\n  /**\n   * Custom separator node.\n   */\n  separator: PropTypes.node\n} : void 0;\nexport default withStyles(styles, {\n  name: 'MuiBreadcrumbs'\n})(Breadcrumbs);","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"@babel/runtime/helpers/esm/setPrototypeOf\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","export default function _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport isNativeReflectConstruct from \"@babel/runtime/helpers/esm/isNativeReflectConstruct\";\nimport possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nexport default function _createSuper(Derived) {\n  var hasNativeReflectConstruct = isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return possibleConstructorReturn(this, result);\n  };\n}","\r\n\r\nvar UZIP = {};\r\nif(typeof module == \"object\") module.exports = UZIP;\r\n\r\n\r\nUZIP[\"parse\"] = function(buf, onlyNames)\t// ArrayBuffer\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint, o = 0, out = {};\r\n\tvar data = new Uint8Array(buf);\r\n\tvar eocd = data.length-4;\r\n\t\r\n\twhile(rUi(data, eocd)!=0x06054b50) eocd--;\r\n\t\r\n\tvar o = eocd;\r\n\to+=4;\t// sign  = 0x06054b50\r\n\to+=4;  // disks = 0;\r\n\tvar cnu = rUs(data, o);  o+=2;\r\n\tvar cnt = rUs(data, o);  o+=2;\r\n\t\t\t\r\n\tvar csize = rUi(data, o);  o+=4;\r\n\tvar coffs = rUi(data, o);  o+=4;\r\n\t\r\n\to = coffs;\r\n\tfor(var i=0; i<cnu; i++)\r\n\t{\r\n\t\tvar sign = rUi(data, o);  o+=4;\r\n\t\to += 4;  // versions;\r\n\t\to += 4;  // flag + compr\r\n\t\to += 4;  // time\r\n\t\t\r\n\t\tvar crc32 = rUi(data, o);  o+=4;\r\n\t\tvar csize = rUi(data, o);  o+=4;\r\n\t\tvar usize = rUi(data, o);  o+=4;\r\n\t\t\r\n\t\tvar nl = rUs(data, o), el = rUs(data, o+2), cl = rUs(data, o+4);  o += 6;  // name, extra, comment\r\n\t\to += 8;  // disk, attribs\r\n\t\t\r\n\t\tvar roff = rUi(data, o);  o+=4;\r\n\t\to += nl + el + cl;\r\n\t\t\r\n\t\tUZIP._readLocal(data, roff, out, csize, usize, onlyNames);\r\n\t}\r\n\t//console.log(out);\r\n\treturn out;\r\n}\r\n\r\nUZIP._readLocal = function(data, o, out, csize, usize, onlyNames)\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint;\r\n\tvar sign  = rUi(data, o);  o+=4;\r\n\tvar ver   = rUs(data, o);  o+=2;\r\n\tvar gpflg = rUs(data, o);  o+=2;\r\n\t//if((gpflg&8)!=0) throw \"unknown sizes\";\r\n\tvar cmpr  = rUs(data, o);  o+=2;\r\n\t\r\n\tvar time  = rUi(data, o);  o+=4;\r\n\t\r\n\tvar crc32 = rUi(data, o);  o+=4;\r\n\t//var csize = rUi(data, o);  o+=4;\r\n\t//var usize = rUi(data, o);  o+=4;\r\n\to+=8;\r\n\t\t\r\n\tvar nlen  = rUs(data, o);  o+=2;\r\n\tvar elen  = rUs(data, o);  o+=2;\r\n\t\t\r\n\tvar name =  UZIP.bin.readUTF8(data, o, nlen);  o+=nlen;  //console.log(name);\r\n\to += elen;\r\n\t\t\t\r\n\t//console.log(sign.toString(16), ver, gpflg, cmpr, crc32.toString(16), \"csize, usize\", csize, usize, nlen, elen, name, o);\r\n\tif(onlyNames) {  out[name]={size:usize, csize:csize};  return;  }   \r\n\tvar file = new Uint8Array(data.buffer, o);\r\n\tif(false) {}\r\n\telse if(cmpr==0) out[name] = new Uint8Array(file.buffer.slice(o, o+csize));\r\n\telse if(cmpr==8) {\r\n\t\tvar buf = new Uint8Array(usize);  UZIP.inflateRaw(file, buf);\r\n\t\t/*var nbuf = pako[\"inflateRaw\"](file);\r\n\t\tif(usize>8514000) {\r\n\t\t\t//console.log(PUtils.readASCII(buf , 8514500, 500));\r\n\t\t\t//console.log(PUtils.readASCII(nbuf, 8514500, 500));\r\n\t\t}\r\n\t\tfor(var i=0; i<buf.length; i++) if(buf[i]!=nbuf[i]) {  console.log(buf.length, nbuf.length, usize, i);  throw \"e\";  }\r\n\t\t*/\r\n\t\tout[name] = buf;\r\n\t}\r\n\telse throw \"unknown compression method: \"+cmpr;\r\n}\r\n\r\nUZIP.inflateRaw = function(file, buf) {  return UZIP.F.inflate(file, buf);  }\r\nUZIP.inflate    = function(file, buf) { \r\n\tvar CMF = file[0], FLG = file[1];\r\n\tvar CM = (CMF&15), CINFO = (CMF>>>4);\r\n\t//console.log(CM, CINFO,CMF,FLG);\r\n\treturn UZIP.inflateRaw(new Uint8Array(file.buffer, file.byteOffset+2, file.length-6), buf);  \r\n}\r\nUZIP.deflate    = function(data, opts/*, buf, off*/) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar off=0, buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tbuf[off]=120;  buf[off+1]=156;  off+=2;\r\n\toff = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\tvar crc = UZIP.adler(data, 0, data.length);\r\n\tbuf[off+0]=((crc>>>24)&255); \r\n\tbuf[off+1]=((crc>>>16)&255); \r\n\tbuf[off+2]=((crc>>> 8)&255); \r\n\tbuf[off+3]=((crc>>> 0)&255); \t\r\n\treturn new Uint8Array(buf.buffer, 0, off+4);\r\n}\r\nUZIP.deflateRaw = function(data, opts) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tvar off = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\treturn new Uint8Array(buf.buffer, 0, off);\r\n}\r\n\r\n\r\nUZIP.encode = function(obj, noCmpr) {\r\n\tif(noCmpr==null) noCmpr=false;\r\n\tvar tot = 0, wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar zpd = {};\r\n\tfor(var p in obj) {  var cpr = !UZIP._noNeed(p) && !noCmpr, buf = obj[p], crc = UZIP.crc.crc(buf,0,buf.length); \r\n\t\tzpd[p] = {  cpr:cpr, usize:buf.length, crc:crc, file: (cpr ? UZIP.deflateRaw(buf) : buf)  };  }\r\n\t\r\n\tfor(var p in zpd) tot += zpd[p].file.length + 30 + 46 + 2*UZIP.bin.sizeUTF8(p);\r\n\ttot +=  22;\r\n\t\r\n\tvar data = new Uint8Array(tot), o = 0;\r\n\tvar fof = []\r\n\t\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 0);\r\n\t}\r\n\tvar i=0, ioff = o;\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 1, fof[i++]);\t\t\r\n\t}\r\n\tvar csize = o-ioff;\r\n\t\r\n\twUi(data, o, 0x06054b50);  o+=4;\r\n\to += 4;  // disks\r\n\twUs(data, o, i);  o += 2;\r\n\twUs(data, o, i);  o += 2;\t// number of c d records\r\n\twUi(data, o, csize);  o += 4;\r\n\twUi(data, o, ioff );  o += 4;\r\n\to += 2;\r\n\treturn data.buffer;\r\n}\r\n// no need to compress .PNG, .ZIP, .JPEG ....\r\nUZIP._noNeed = function(fn) {  var ext = fn.split(\".\").pop().toLowerCase();  return \"png,jpg,jpeg,zip\".indexOf(ext)!=-1;  }\r\n\r\nUZIP._writeHeader = function(data, o, p, obj, t, roff)\r\n{\r\n\tvar wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar file = obj.file;\r\n\t\r\n\twUi(data, o, t==0 ? 0x04034b50 : 0x02014b50);  o+=4; // sign\r\n\tif(t==1) o+=2;  // ver made by\r\n\twUs(data, o, 20);  o+=2;\t// ver\r\n\twUs(data, o,  0);  o+=2;    // gflip\r\n\twUs(data, o,  obj.cpr?8:0);  o+=2;\t// cmpr\r\n\t\t\r\n\twUi(data, o,  0);  o+=4;\t// time\t\t\r\n\twUi(data, o, obj.crc);  o+=4;\t// crc32\r\n\twUi(data, o, file.length);  o+=4;\t// csize\r\n\twUi(data, o, obj.usize);  o+=4;\t// usize\r\n\t\t\r\n\twUs(data, o, UZIP.bin.sizeUTF8(p));  o+=2;\t// nlen\r\n\twUs(data, o, 0);  o+=2;\t// elen\r\n\t\r\n\tif(t==1) {\r\n\t\to += 2;  // comment length\r\n\t\to += 2;  // disk number\r\n\t\to += 6;  // attributes\r\n\t\twUi(data, o, roff);  o+=4;\t// usize\r\n\t}\r\n\tvar nlen = UZIP.bin.writeUTF8(data, o, p);  o+= nlen;\t\r\n\tif(t==0) {  data.set(file, o);  o += file.length;  }\r\n\treturn o;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = UZIP.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return UZIP.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n}\r\nUZIP.adler = function(data,o,len) {\r\n\tvar a = 1, b = 0;\r\n\tvar off = o, end=o+len;\r\n\twhile(off<end) {\r\n\t\tvar eend = Math.min(off+5552, end);\r\n\t\twhile(off<eend) {\r\n\t\t\ta += data[off++];\r\n\t\t\tb += a;\r\n\t\t}\r\n\t\ta=a%65521;\r\n\t\tb=b%65521;\r\n\t}\r\n    return (b << 16) | a;\r\n}\r\n\r\nUZIP.bin = {\r\n\treadUshort : function(buff,p)  {  return (buff[p]) | (buff[p+1]<<8);  },\r\n\twriteUshort: function(buff,p,n){  buff[p] = (n)&255;  buff[p+1] = (n>>8)&255;  },\r\n\treadUint   : function(buff,p)  {  return (buff[p+3]*(256*256*256)) + ((buff[p+2]<<16) | (buff[p+1]<< 8) | buff[p]);  },\r\n\twriteUint  : function(buff,p,n){  buff[p]=n&255;  buff[p+1]=(n>>8)&255;  buff[p+2]=(n>>16)&255;  buff[p+3]=(n>>24)&255;  },\r\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\r\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\r\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\r\n\treadUTF8 : function(buff, p, l) {\r\n\t\tvar s = \"\", ns;\r\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UZIP.bin.pad(buff[p+i].toString(16));\r\n\t\ttry {  ns = decodeURIComponent(s); }\r\n\t\tcatch(e) {  return UZIP.bin.readASCII(buff, p, l);  }\r\n\t\treturn  ns;\r\n\t},\r\n\twriteUTF8 : function(buff, p, str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  buff[p+i] = (     code     );  i++;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  buff[p+i] = (192|(code>> 6));  buff[p+i+1] = (128|((code>> 0)&63));  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  buff[p+i] = (224|(code>>12));  buff[p+i+1] = (128|((code>> 6)&63));  buff[p+i+2] = (128|((code>>0)&63));  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  buff[p+i] = (240|(code>>18));  buff[p+i+1] = (128|((code>>12)&63));  buff[p+i+2] = (128|((code>>6)&63));  buff[p+i+3] = (128|((code>>0)&63)); i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t},\r\n\tsizeUTF8 : function(str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  i++ ;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F = {};\r\n\r\nUZIP.F.deflateRaw = function(data, out, opos, lvl) {\t\r\n\tvar opts = [\r\n\t/*\r\n\t\t ush good_length; /* reduce lazy search above this match length \r\n\t\t ush max_lazy;    /* do not perform lazy search above this match length \r\n         ush nice_length; /* quit search above this match length \r\n\t*/\r\n\t/*      good lazy nice chain */\r\n\t/* 0 */ [ 0,   0,   0,    0,0],  /* store only */\r\n\t/* 1 */ [ 4,   4,   8,    4,0], /* max speed, no lazy matches */\r\n\t/* 2 */ [ 4,   5,  16,    8,0],\r\n\t/* 3 */ [ 4,   6,  16,   16,0],\r\n\r\n\t/* 4 */ [ 4,  10,  16,   32,0],  /* lazy matches */\r\n\t/* 5 */ [ 8,  16,  32,   32,0],\r\n\t/* 6 */ [ 8,  16, 128,  128,0],\r\n\t/* 7 */ [ 8,  32, 128,  256,0],\r\n\t/* 8 */ [32, 128, 258, 1024,1],\r\n\t/* 9 */ [32, 258, 258, 4096,1]]; /* max compression */\r\n\t\r\n\tvar opt = opts[lvl];\r\n\t\r\n\t\r\n\tvar U = UZIP.F.U, goodIndex = UZIP.F._goodIndex, hash = UZIP.F._hash, putsE = UZIP.F._putsE;\r\n\tvar i = 0, pos = opos<<3, cvrd = 0, dlen = data.length;\r\n\t\r\n\tif(lvl==0) {\r\n\t\twhile(i<dlen) {   var len = Math.min(0xffff, dlen-i);\r\n\t\t\tputsE(out, pos, (i+len==dlen ? 1 : 0));  pos = UZIP.F._copyExact(data, i, len, out, pos+8);  i += len;  }\r\n\t\treturn pos>>>3;\r\n\t}\r\n\r\n\tvar lits = U.lits, strt=U.strt, prev=U.prev, li=0, lc=0, bs=0, ebits=0, c=0, nc=0;  // last_item, literal_count, block_start\r\n\tif(dlen>2) {  nc=UZIP.F._hash(data,0);  strt[nc]=0;  }\r\n\tvar nmch=0,nmci=0;\r\n\t\r\n\tfor(i=0; i<dlen; i++)  {\r\n\t\tc = nc;\r\n\t\t//*\r\n\t\tif(i+1<dlen-2) {\r\n\t\t\tnc = UZIP.F._hash(data, i+1);\r\n\t\t\tvar ii = ((i+1)&0x7fff);\r\n\t\t\tprev[ii]=strt[nc];\r\n\t\t\tstrt[nc]=ii;\r\n\t\t} //*/\r\n\t\tif(cvrd<=i) {\r\n\t\t\tif((li>14000 || lc>26697) && (dlen-i)>100) {\r\n\t\t\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\t\t\tpos = UZIP.F._writeBlock(((i==dlen-1) || (cvrd==dlen))?1:0, lits, li, ebits, data,bs,i-bs, out, pos);  li=lc=ebits=0;  bs=i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar mch = 0;\r\n\t\t\t//if(nmci==i) mch= nmch;  else \r\n\t\t\tif(i<dlen-2) mch = UZIP.F._bestMatch(data, i, prev, c, Math.min(opt[2],dlen-i), opt[3]);\r\n\t\t\t/*\r\n\t\t\tif(mch!=0 && opt[4]==1 && (mch>>>16)<opt[1] && i+1<dlen-2) {\r\n\t\t\t\tnmch = UZIP.F._bestMatch(data, i+1, prev, nc, opt[2], opt[3]);  nmci=i+1;\r\n\t\t\t\t//var mch2 = UZIP.F._bestMatch(data, i+2, prev, nnc);  //nmci=i+1;\r\n\t\t\t\tif((nmch>>>16)>(mch>>>16)) mch=0;\r\n\t\t\t}//*/\r\n\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\tif(mch!=0) { \r\n\t\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\t\tvar lgi = goodIndex(len, U.of0);  U.lhst[257+lgi]++; \r\n\t\t\t\tvar dgi = goodIndex(dst, U.df0);  U.dhst[    dgi]++;  ebits += U.exb[lgi] + U.dxb[dgi]; \r\n\t\t\t\tlits[li] = (len<<23)|(i-cvrd);  lits[li+1] = (dst<<16)|(lgi<<8)|dgi;  li+=2;\r\n\t\t\t\tcvrd = i + len;  \r\n\t\t\t}\r\n\t\t\telse {\tU.lhst[data[i]]++;  }\r\n\t\t\tlc++;\r\n\t\t}\r\n\t}\r\n\tif(bs!=i || data.length==0) {\r\n\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\tpos = UZIP.F._writeBlock(1, lits, li, ebits, data,bs,i-bs, out, pos);  li=0;  lc=0;  li=lc=ebits=0;  bs=i;\r\n\t}\r\n\twhile((pos&7)!=0) pos++;\r\n\treturn pos>>>3;\r\n}\r\nUZIP.F._bestMatch = function(data, i, prev, c, nice, chain) {\r\n\tvar ci = (i&0x7fff), pi=prev[ci];  \r\n\t//console.log(\"----\", i);\r\n\tvar dif = ((ci-pi + (1<<15)) & 0x7fff);  if(pi==ci || c!=UZIP.F._hash(data,i-dif)) return 0;\r\n\tvar tl=0, td=0;  // top length, top distance\r\n\tvar dlim = Math.min(0x7fff, i);\r\n\twhile(dif<=dlim && --chain!=0 && pi!=ci /*&& c==UZIP.F._hash(data,i-dif)*/) {\r\n\t\tif(tl==0 || (data[i+tl]==data[i+tl-dif])) {\r\n\t\t\tvar cl = UZIP.F._howLong(data, i, dif);\r\n\t\t\tif(cl>tl) {  \r\n\t\t\t\ttl=cl;  td=dif;  if(tl>=nice) break;    //* \r\n\t\t\t\tif(dif+2<cl) cl = dif+2;\r\n\t\t\t\tvar maxd = 0; // pi does not point to the start of the word\r\n\t\t\t\tfor(var j=0; j<cl-2; j++) {\r\n\t\t\t\t\tvar ei =  (i-dif+j+ (1<<15)) & 0x7fff;\r\n\t\t\t\t\tvar li = prev[ei];\r\n\t\t\t\t\tvar curd = (ei-li + (1<<15)) & 0x7fff;\r\n\t\t\t\t\tif(curd>maxd) {  maxd=curd;  pi = ei; }\r\n\t\t\t\t}  //*/\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tci=pi;  pi = prev[ci];\r\n\t\tdif += ((ci-pi + (1<<15)) & 0x7fff);\r\n\t}\r\n\treturn (tl<<16)|td;\r\n}\r\nUZIP.F._howLong = function(data, i, dif) {\r\n\tif(data[i]!=data[i-dif] || data[i+1]!=data[i+1-dif] || data[i+2]!=data[i+2-dif]) return 0;\r\n\tvar oi=i, l = Math.min(data.length, i+258);  i+=3;\r\n\t//while(i+4<l && data[i]==data[i-dif] && data[i+1]==data[i+1-dif] && data[i+2]==data[i+2-dif] && data[i+3]==data[i+3-dif]) i+=4;\r\n\twhile(i<l && data[i]==data[i-dif]) i++;\r\n\treturn i-oi;\r\n}\r\nUZIP.F._hash = function(data, i) {\r\n\treturn (((data[i]<<8) | data[i+1])+(data[i+2]<<4))&0xffff;\r\n\t//var hash_shift = 0, hash_mask = 255;\r\n\t//var h = data[i+1] % 251;\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = ((h<<hash_shift) ^ (c) ) & hash_mask;\r\n\t//return h | (data[i]<<8);\r\n\t//return (data[i] | (data[i+1]<<8));\r\n}\r\n//UZIP.___toth = 0;\r\nUZIP.saved = 0;\r\nUZIP.F._writeBlock = function(BFINAL, lits, li, ebits, data,o0,l0, out, pos) {\r\n\tvar U = UZIP.F.U, putsF = UZIP.F._putsF, putsE = UZIP.F._putsE;\r\n\t\r\n\t//*\r\n\tvar T, ML, MD, MH, numl, numd, numh, lset, dset;  U.lhst[256]++;\r\n\tT = UZIP.F.getTrees(); ML=T[0]; MD=T[1]; MH=T[2]; numl=T[3]; numd=T[4]; numh=T[5]; lset=T[6]; dset=T[7];\r\n\t\r\n\tvar cstSize = (((pos+3)&7)==0 ? 0 : 8-((pos+3)&7)) + 32 + (l0<<3);\r\n\tvar fxdSize = ebits + UZIP.F.contSize(U.fltree, U.lhst) + UZIP.F.contSize(U.fdtree, U.dhst);\r\n\tvar dynSize = ebits + UZIP.F.contSize(U.ltree , U.lhst) + UZIP.F.contSize(U.dtree , U.dhst);\r\n\tdynSize    += 14 + 3*numh + UZIP.F.contSize(U.itree, U.ihst) + (U.ihst[16]*2 + U.ihst[17]*3 + U.ihst[18]*7);\r\n\t\r\n\tfor(var j=0; j<286; j++) U.lhst[j]=0;   for(var j=0; j<30; j++) U.dhst[j]=0;   for(var j=0; j<19; j++) U.ihst[j]=0;\r\n\t//*/\r\n\tvar BTYPE = (cstSize<fxdSize && cstSize<dynSize) ? 0 : ( fxdSize<dynSize ? 1 : 2 );\r\n\tputsF(out, pos, BFINAL);  putsF(out, pos+1, BTYPE);  pos+=3;\r\n\t\r\n\tvar opos = pos;\r\n\tif(BTYPE==0) {\r\n\t\twhile((pos&7)!=0) pos++;\r\n\t\tpos = UZIP.F._copyExact(data, o0, l0, out, pos);\r\n\t}\r\n\telse {\r\n\t\tvar ltree, dtree;\r\n\t\tif(BTYPE==1) {  ltree=U.fltree;  dtree=U.fdtree;  }\r\n\t\tif(BTYPE==2) {\t\r\n\t\t\tUZIP.F.makeCodes(U.ltree, ML);  UZIP.F.revCodes(U.ltree, ML);\r\n\t\t\tUZIP.F.makeCodes(U.dtree, MD);  UZIP.F.revCodes(U.dtree, MD);\r\n\t\t\tUZIP.F.makeCodes(U.itree, MH);  UZIP.F.revCodes(U.itree, MH);\r\n\t\t\t\r\n\t\t\tltree = U.ltree;  dtree = U.dtree;\r\n\t\t\t\r\n\t\t\tputsE(out, pos,numl-257);  pos+=5;  // 286\r\n\t\t\tputsE(out, pos,numd-  1);  pos+=5;  // 30\r\n\t\t\tputsE(out, pos,numh-  4);  pos+=4;  // 19\r\n\t\t\t\r\n\t\t\tfor(var i=0; i<numh; i++) putsE(out, pos+i*3, U.itree[(U.ordr[i]<<1)+1]);   pos+=3* numh;\r\n\t\t\tpos = UZIP.F._codeTiny(lset, U.itree, out, pos);\r\n\t\t\tpos = UZIP.F._codeTiny(dset, U.itree, out, pos);\r\n\t\t}\r\n\t\t\r\n\t\tvar off=o0;\r\n\t\tfor(var si=0; si<li; si+=2) {\r\n\t\t\tvar qb=lits[si], len=(qb>>>23), end = off+(qb&((1<<23)-1));\r\n\t\t\twhile(off<end) pos = UZIP.F._writeLit(data[off++], ltree, out, pos);\r\n\t\t\t\r\n\t\t\tif(len!=0) {\r\n\t\t\t\tvar qc = lits[si+1], dst=(qc>>16), lgi=(qc>>8)&255, dgi=(qc&255);\r\n\t\t\t\tpos = UZIP.F._writeLit(257+lgi, ltree, out, pos);\r\n\t\t\t\tputsE(out, pos, len-U.of0[lgi]);  pos+=U.exb[lgi];\r\n\t\t\t\t\r\n\t\t\t\tpos = UZIP.F._writeLit(dgi, dtree, out, pos);\r\n\t\t\t\tputsF(out, pos, dst-U.df0[dgi]);  pos+=U.dxb[dgi];  off+=len;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpos = UZIP.F._writeLit(256, ltree, out, pos);\r\n\t}\r\n\t//console.log(pos-opos, fxdSize, dynSize, cstSize);\r\n\treturn pos;\r\n}\r\nUZIP.F._copyExact = function(data,off,len,out,pos) {\r\n\tvar p8 = (pos>>>3);\r\n\tout[p8]=(len);  out[p8+1]=(len>>>8);  out[p8+2]=255-out[p8];  out[p8+3]=255-out[p8+1];  p8+=4;\r\n\tout.set(new Uint8Array(data.buffer, off, len), p8);\r\n\t//for(var i=0; i<len; i++) out[p8+i]=data[off+i];\r\n\treturn pos + ((len+4)<<3);\r\n}\r\n/*\r\n\tInteresting facts:\r\n\t- decompressed block can have bytes, which do not occur in a Huffman tree (copied from the previous block by reference)\r\n*/\r\n\r\nUZIP.F.getTrees = function() {\r\n\tvar U = UZIP.F.U;\r\n\tvar ML = UZIP.F._hufTree(U.lhst, U.ltree, 15);\r\n\tvar MD = UZIP.F._hufTree(U.dhst, U.dtree, 15);\r\n\tvar lset = [], numl = UZIP.F._lenCodes(U.ltree, lset);\r\n\tvar dset = [], numd = UZIP.F._lenCodes(U.dtree, dset);\r\n\tfor(var i=0; i<lset.length; i+=2) U.ihst[lset[i]]++;\r\n\tfor(var i=0; i<dset.length; i+=2) U.ihst[dset[i]]++;\r\n\tvar MH = UZIP.F._hufTree(U.ihst, U.itree,  7);\r\n\tvar numh = 19;  while(numh>4 && U.itree[(U.ordr[numh-1]<<1)+1]==0) numh--;\r\n\treturn [ML, MD, MH, numl, numd, numh, lset, dset];\r\n}\r\nUZIP.F.getSecond= function(a) {  var b=[];  for(var i=0; i<a.length; i+=2) b.push  (a[i+1]);  return b;  }\r\nUZIP.F.nonZero  = function(a) {  var b= \"\";  for(var i=0; i<a.length; i+=2) if(a[i+1]!=0)b+=(i>>1)+\",\";  return b;  }\r\nUZIP.F.contSize = function(tree, hst) {  var s=0;  for(var i=0; i<hst.length; i++) s+= hst[i]*tree[(i<<1)+1];  return s;  }\r\nUZIP.F._codeTiny = function(set, tree, out, pos) {\r\n\tfor(var i=0; i<set.length; i+=2) {\r\n\t\tvar l = set[i], rst = set[i+1];  //console.log(l, pos, tree[(l<<1)+1]);\r\n\t\tpos = UZIP.F._writeLit(l, tree, out, pos);\r\n\t\tvar rsl = l==16 ? 2 : (l==17 ? 3 : 7);\r\n\t\tif(l>15) {  UZIP.F._putsE(out, pos, rst, rsl);  pos+=rsl;  }\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._lenCodes = function(tree, set) {\r\n\tvar len=tree.length;  while(len!=2 && tree[len-1]==0) len-=2;  // when no distances, keep one code with length 0\r\n\tfor(var i=0; i<len; i+=2) {\r\n\t\tvar l = tree[i+1], nxt = (i+3<len ? tree[i+3]:-1),  nnxt = (i+5<len ? tree[i+5]:-1),  prv = (i==0 ? -1 : tree[i-1]);\r\n\t\tif(l==0 && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 138);\r\n\t\t\tif(zc<11) set.push(17, zc-3);\r\n\t\t\telse set.push(18, zc-11);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse if(l==prv && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 6);\r\n\t\t\tset.push(16, zc-3);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse set.push(l, 0);\r\n\t}\r\n\treturn len>>>1;\r\n}\r\nUZIP.F._hufTree   = function(hst, tree, MAXL) {\r\n\tvar list=[], hl = hst.length, tl=tree.length, i=0;\r\n\tfor(i=0; i<tl; i+=2) {  tree[i]=0;  tree[i+1]=0;  }\t\r\n\tfor(i=0; i<hl; i++) if(hst[i]!=0) list.push({lit:i, f:hst[i]});\r\n\tvar end = list.length, l2=list.slice(0);\r\n\tif(end==0) return 0;  // empty histogram (usually for dist)\r\n\tif(end==1) {  var lit=list[0].lit, l2=lit==0?1:0;  tree[(lit<<1)+1]=1;  tree[(l2<<1)+1]=1;  return 1;  }\r\n\tlist.sort(function(a,b){return a.f-b.f;});\r\n\tvar a=list[0], b=list[1], i0=0, i1=1, i2=2;  list[0]={lit:-1,f:a.f+b.f,l:a,r:b,d:0};\r\n\twhile(i1!=end-1) {\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  a=list[i0++];  }  else {  a=list[i2++];  }\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  b=list[i0++];  }  else {  b=list[i2++];  }\r\n\t\tlist[i1++]={lit:-1,f:a.f+b.f, l:a,r:b};\r\n\t}\r\n\tvar maxl = UZIP.F.setDepth(list[i1-1], 0);\r\n\tif(maxl>MAXL) {  UZIP.F.restrictDepth(l2, MAXL, maxl);  maxl = MAXL;  }\r\n\tfor(i=0; i<end; i++) tree[(l2[i].lit<<1)+1]=l2[i].d;\r\n\treturn maxl;\r\n}\r\n\r\nUZIP.F.setDepth  = function(t, d) {\r\n\tif(t.lit!=-1) {  t.d=d;  return d;  }\r\n\treturn Math.max( UZIP.F.setDepth(t.l, d+1),  UZIP.F.setDepth(t.r, d+1) );\r\n}\r\n\r\nUZIP.F.restrictDepth = function(dps, MD, maxl) {\r\n\tvar i=0, bCost=1<<(maxl-MD), dbt=0;\r\n\tdps.sort(function(a,b){return b.d==a.d ? a.f-b.f : b.d-a.d;});\r\n\t\r\n\tfor(i=0; i<dps.length; i++) if(dps[i].d>MD) {  var od=dps[i].d;  dps[i].d=MD;  dbt+=bCost-(1<<(maxl-od));  }  else break;\r\n\tdbt = dbt>>>(maxl-MD);\r\n\twhile(dbt>0) {  var od=dps[i].d;  if(od<MD) {  dps[i].d++;  dbt-=(1<<(MD-od-1));  }  else  i++;  }\r\n\tfor(; i>=0; i--) if(dps[i].d==MD && dbt<0) {  dps[i].d--;  dbt++;  }  if(dbt!=0) console.log(\"debt left\");\r\n}\r\n\r\nUZIP.F._goodIndex = function(v, arr) {\r\n\tvar i=0;  if(arr[i|16]<=v) i|=16;  if(arr[i|8]<=v) i|=8;  if(arr[i|4]<=v) i|=4;  if(arr[i|2]<=v) i|=2;  if(arr[i|1]<=v) i|=1;  return i;\r\n}\r\nUZIP.F._writeLit = function(ch, ltree, out, pos) {\r\n\tUZIP.F._putsF(out, pos, ltree[ch<<1]);\r\n\treturn pos+ltree[(ch<<1)+1];\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F.inflate = function(data, buf) {\r\n\tvar u8=Uint8Array;\r\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\r\n\tvar F=UZIP.F, bitsF = F._bitsF, bitsE = F._bitsE, decodeTiny = F._decodeTiny, makeCodes = F.makeCodes, codes2map=F.codes2map, get17 = F._get17;\r\n\tvar U = F.U;\r\n\t\r\n\tvar noBuf = (buf==null);\r\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\r\n\t\r\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\r\n\tvar off = 0, pos = 0;\r\n\tvar lmap, dmap;\r\n\t\r\n\twhile(BFINAL==0) {\t\t\r\n\t\tBFINAL = bitsF(data, pos  , 1);\r\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\r\n\t\t//console.log(BFINAL, BTYPE);\r\n\t\t\r\n\t\tif(BTYPE==0) {\r\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\r\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \r\n\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+len);\r\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\r\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\r\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\r\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\r\n\t\t}\r\n\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\r\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\r\n\t\tif(BTYPE==2) {\r\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \r\n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \r\n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\r\n\t\t\t\r\n\t\t\tvar ppos = pos;\r\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\r\n\t\t\tvar tl = 1;\r\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\r\n\t\t\tmakeCodes(U.itree, tl);\r\n\t\t\tcodes2map(U.itree, tl, U.imap);\r\n\t\t\t\r\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\r\n\t\t\t\r\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\r\n\t\t\tvar mx0 = F._copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\r\n\t\t\tvar mx1 = F._copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\r\n\t\t\t\r\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\r\n\t\t\tmakeCodes(U.ltree, mx0);\r\n\t\t\tcodes2map(U.ltree, mx0, lmap);\r\n\t\t\t\r\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\r\n\t\t\tmakeCodes(U.dtree, mx1);\r\n\t\t\tcodes2map(U.dtree, mx1, dmap);\r\n\t\t}\r\n\t\t//var ooff=off, opos=pos;\r\n\t\twhile(true) {\r\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\r\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \r\n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\r\n\t\t\telse if(lit==256) {  break;  }\r\n\t\t\telse {\r\n\t\t\t\tvar end = off+lit-254;\r\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\r\n\t\t\t\t//UZIP.F.dst[end-off]++;\r\n\t\t\t\t\r\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\r\n\t\t\t\tvar dlit = dcode>>>4;\r\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\r\n\t\t\t\t\r\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\r\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\r\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\r\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\r\n\t\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));\r\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \r\n\t\t\t\toff=end;\r\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\r\n\t\t\t}\r\n\t\t}\r\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\r\n\t}\r\n\t//console.log(UZIP.F.dst);\r\n\t//console.log(tlen, dlen, off-tlen+tcnt);\r\n\treturn buf.length==off ? buf : buf.slice(0,off);\r\n}\r\nUZIP.F._check=function(buf, len) {\r\n\tvar bl=buf.length;  if(len<=bl) return buf;\r\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\r\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\r\n\treturn nbuf;\r\n}\r\n\r\nUZIP.F._decodeTiny = function(lmap, LL, len, data, pos, tree) {\r\n\tvar bitsE = UZIP.F._bitsE, get17 = UZIP.F._get17;\r\n\tvar i = 0;\r\n\twhile(i<len) {\r\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\r\n\t\tvar lit = code>>>4; \r\n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\r\n\t\telse {\r\n\t\t\tvar ll = 0, n = 0;\r\n\t\t\tif(lit==16) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\r\n\t\t\t}\r\n\t\t\telse if(lit==17) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\r\n\t\t\t}\r\n\t\t\telse if(lit==18) {\r\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\r\n\t\t\t}\r\n\t\t\tvar ni = i+n;\r\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._copyOut = function(src, off, len, tree) {\r\n\tvar mx=0, i=0, tl=tree.length>>>1;\r\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\r\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\r\n\treturn mx;\r\n}\r\n\r\nUZIP.F.makeCodes = function(tree, MAX_BITS) {  // code, length\r\n\tvar U = UZIP.F.U;\r\n\tvar max_code = tree.length;\r\n\tvar code, bits, n, i, len;\r\n\t\r\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\r\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\r\n\t\r\n\tvar next_code = U.next_code;\t// smallest code for each length\r\n\t\r\n\tcode = 0;\r\n\tbl_count[0] = 0;\r\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\r\n\t\tcode = (code + bl_count[bits-1]) << 1;\r\n\t\tnext_code[bits] = code;\r\n\t}\r\n\t\r\n\tfor (n = 0; n < max_code; n+=2) {\r\n\t\tlen = tree[n+1];\r\n\t\tif (len != 0) {\r\n\t\t\ttree[n] = next_code[len];\r\n\t\t\tnext_code[len]++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.codes2map = function(tree, MAX_BITS, map) {\r\n\tvar max_code = tree.length;\r\n\tvar U=UZIP.F.U, r15 = U.rev15;\r\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\r\n\t\tvar lit = i>>1;\r\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\r\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\r\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\r\n\t\twhile(i0!=i1) {\r\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\r\n\t\t\tmap[p0]=val;  i0++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.revCodes = function(tree, MAX_BITS) {\r\n\tvar r15 = UZIP.F.U.rev15, imb = 15-MAX_BITS;\r\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\r\n}\r\n\r\n// used only in deflate\r\nUZIP.F._putsE= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);                        }\r\nUZIP.F._putsF= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);  dt[o+2]|=(val>>>16);  }\r\n\r\nUZIP.F._bitsE= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\r\nUZIP.F._bitsF= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\r\n/*\r\nUZIP.F._get9 = function(dt, pos) {\r\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\r\n} */\r\nUZIP.F._get17= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\r\n}\r\nUZIP.F._get25= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) | (dt[(pos>>>3)+3]<<24) )>>>(pos&7);\r\n}\r\nUZIP.F.U = function(){\r\n\tvar u16=Uint16Array, u32=Uint32Array;\r\n\treturn {\r\n\t\tnext_code : new u16(16),\r\n\t\tbl_count  : new u16(16),\r\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\r\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\r\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\r\n\t\tldef : new u16(32),\r\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\r\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\r\n\t\tddef : new u32(32),\r\n\t\tflmap: new u16(  512),  fltree: [],\r\n\t\tfdmap: new u16(   32),  fdtree: [],\r\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\r\n\t\tdmap : new u16(32768),  dtree : [],\r\n\t\timap : new u16(  512),  itree : [],\r\n\t\t//rev9 : new u16(  512)\r\n\t\trev15: new u16(1<<15),\r\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\r\n\t\tlits : new u32(15000),\r\n\t\tstrt : new u16(1<<16),\r\n\t\tprev : new u16(1<<15)\r\n\t};  \r\n} ();\r\n\r\n(function(){\t\r\n\tvar U = UZIP.F.U;\r\n\tvar len = 1<<15;\r\n\tfor(var i=0; i<len; i++) {\r\n\t\tvar x = i;\r\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\r\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\r\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\r\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\r\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\r\n\t}\r\n\t\r\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\r\n\t\r\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\r\n\t\r\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\r\n\t/*\r\n\tvar i = 0;\r\n\tfor(; i<=143; i++) U.fltree.push(0,8);\r\n\tfor(; i<=255; i++) U.fltree.push(0,9);\r\n\tfor(; i<=279; i++) U.fltree.push(0,7);\r\n\tfor(; i<=287; i++) U.fltree.push(0,8);\r\n\t*/\r\n\tUZIP.F.makeCodes(U.fltree, 9);\r\n\tUZIP.F.codes2map(U.fltree, 9, U.flmap);\r\n\tUZIP.F.revCodes (U.fltree, 9)\r\n\t\r\n\tpushV(U.fdtree,32,5);\r\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\r\n\tUZIP.F.makeCodes(U.fdtree, 5);\r\n\tUZIP.F.codes2map(U.fdtree, 5, U.fdmap);\r\n\tUZIP.F.revCodes (U.fdtree, 5)\r\n\t\r\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\r\n\t/*\r\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\r\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\r\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\r\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\r\n\t*/\r\n})()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// https://github.com/photopea/UPNG.js/blob/c976240e62b0497167f8aafabd7889625f8b2016/UPNG.js\r\n\r\n// import * as pako from 'pako'\r\nimport * as UZIP from 'uzip'\r\n\r\nvar UPNG = {};\r\n\r\n\r\nUPNG.toRGBA8 = function(out)\r\n{\r\n  var w = out.width, h = out.height;\r\n  if(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\r\n\r\n  var frms = [];\r\n  if(out.frames[0].data==null) out.frames[0].data = out.data;\r\n\r\n  var len = w*h*4, img = new Uint8Array(len), empty = new Uint8Array(len), prev=new Uint8Array(len);\r\n  for(var i=0; i<out.frames.length; i++)\r\n  {\r\n    var frm = out.frames[i];\r\n    var fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\r\n    var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);\r\n\r\n    if(i!=0) for(var j=0; j<len; j++) prev[j]=img[j];\r\n\r\n    if     (frm.blend==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\r\n    else if(frm.blend==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\r\n\r\n    frms.push(img.buffer.slice(0));\r\n\r\n    if     (frm.dispose==0) {}\r\n    else if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\r\n    else if(frm.dispose==2) for(var j=0; j<len; j++) img[j]=prev[j];\r\n  }\r\n  return frms;\r\n}\r\nUPNG.toRGBA8.decodeImage = function(data, w, h, out)\r\n{\r\n  var area = w*h, bpp = UPNG.decode._getBPP(out);\r\n  var bpl = Math.ceil(w*bpp/8);\t// bytes per line\r\n\r\n  var bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);\r\n  var ctype = out.ctype, depth = out.depth;\r\n  var rs = UPNG._bin.readUshort;\r\n\r\n  //console.log(ctype, depth);\r\n  var time = Date.now();\r\n\r\n  if     (ctype==6) { // RGB + alpha\r\n    var qarea = area<<2;\r\n    if(depth== 8) for(var i=0; i<qarea;i+=4) {  bf[i] = data[i];  bf[i+1] = data[i+1];  bf[i+2] = data[i+2];  bf[i+3] = data[i+3]; }\r\n    if(depth==16) for(var i=0; i<qarea;i++ ) {  bf[i] = data[i<<1];  }\r\n  }\r\n  else if(ctype==2) {\t// RGB\r\n    var ts=out.tabs[\"tRNS\"];\r\n    if(ts==null) {\r\n      if(depth== 8) for(var i=0; i<area; i++) {  var ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];  }\r\n      if(depth==16) for(var i=0; i<area; i++) {  var ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];  }\r\n    }\r\n    else {  var tr=ts[0], tg=ts[1], tb=ts[2];\r\n      if(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];\r\n        if(data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }\r\n      if(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];\r\n        if(rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }\r\n    }\r\n  }\r\n  else if(ctype==3) {\t// palette\r\n    var p=out.tabs[\"PLTE\"], ap=out.tabs[\"tRNS\"], tl=ap?ap.length:0;\r\n    //console.log(p, ap);\r\n    if(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\r\n      for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\r\n    }\r\n    if(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\r\n      for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\r\n    }\r\n    if(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\r\n      for(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\r\n    }\r\n    if(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\r\n  }\r\n  else if(ctype==4) {\t// gray + alpha\r\n    if(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }\r\n    if(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }\r\n  }\r\n  else if(ctype==0) {\t// gray\r\n    var tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\r\n    for(var y=0; y<h; y++) {\r\n      var off = y*bpl, to = y*w;\r\n      if     (depth== 1) for(var x=0; x<w; x++) {  var gr=255*((data[off+(x>>>3)]>>>(7 -((x&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\r\n      else if(depth== 2) for(var x=0; x<w; x++) {  var gr= 85*((data[off+(x>>>2)]>>>(6 -((x&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\r\n      else if(depth== 4) for(var x=0; x<w; x++) {  var gr= 17*((data[off+(x>>>1)]>>>(4 -((x&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\r\n      else if(depth== 8) for(var x=0; x<w; x++) {  var gr=data[off+     x], al=(gr                 ==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\r\n      else if(depth==16) for(var x=0; x<w; x++) {  var gr=data[off+(x<<1)], al=(rs(data,off+(x<<i))==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\r\n    }\r\n  }\r\n  //console.log(Date.now()-time);\r\n  return bf;\r\n}\r\n\r\n\r\n\r\nUPNG.decode = function(buff)\r\n{\r\n  var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\r\n  var out = {tabs:{}, frames:[]};\r\n  var dd = new Uint8Array(data.length), doff = 0;\t // put all IDAT data into it\r\n  var fd, foff = 0;\t// frames\r\n\r\n  var mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\r\n  for(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw \"The input is not a PNG file!\";\r\n\r\n  while(offset<data.length)\r\n  {\r\n    var len  = bin.readUint(data, offset);  offset += 4;\r\n    var type = bin.readASCII(data, offset, 4);  offset += 4;\r\n    //console.log(type,len);\r\n\r\n    if     (type==\"IHDR\")  {  UPNG.decode._IHDR(data, offset, out);  }\r\n    else if(type==\"CgBI\")  {  out.tabs[type] = data.slice(offset,offset+4);  }\r\n    else if(type==\"IDAT\") {\r\n      for(var i=0; i<len; i++) dd[doff+i] = data[offset+i];\r\n      doff += len;\r\n    }\r\n    else if(type==\"acTL\")  {\r\n      out.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };\r\n      fd = new Uint8Array(data.length);\r\n    }\r\n    else if(type==\"fcTL\")  {\r\n      if(foff!=0) {  var fr = out.frames[out.frames.length-1];\r\n        fr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\r\n      }\r\n      var rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};\r\n      var del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);\r\n      var frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};\r\n      //console.log(frm);\r\n      out.frames.push(frm);\r\n    }\r\n    else if(type==\"fdAT\") {\r\n      for(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];\r\n      foff += len-4;\r\n    }\r\n    else if(type==\"pHYs\") {\r\n      out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];\r\n    }\r\n    else if(type==\"cHRM\") {\r\n      out.tabs[type] = [];\r\n      for(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));\r\n    }\r\n    else if(type==\"tEXt\" || type==\"zTXt\") {\r\n      if(out.tabs[type]==null) out.tabs[type] = {};\r\n      var nz = bin.nextZero(data, offset);\r\n      var keyw = bin.readASCII(data, offset, nz-offset);\r\n      var text, tl=offset+len-nz-1;\r\n      if(type==\"tEXt\") text = bin.readASCII(data, nz+1, tl);\r\n      else {\r\n        var bfr = UPNG.decode._inflate(data.slice(nz+2,nz+2+tl));\r\n        text = bin.readUTF8(bfr,0,bfr.length);\r\n      }\r\n      out.tabs[type][keyw] = text;\r\n    }\r\n    else if(type==\"iTXt\") {\r\n      if(out.tabs[type]==null) out.tabs[type] = {};\r\n      var nz = 0, off = offset;\r\n      nz = bin.nextZero(data, off);\r\n      var keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;\r\n      var cflag = data[off], cmeth = data[off+1];  off+=2;\r\n      nz = bin.nextZero(data, off);\r\n      var ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;\r\n      nz = bin.nextZero(data, off);\r\n      var tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;\r\n      var text, tl=len-(off-offset);\r\n      if(cflag==0) text  = bin.readUTF8(data, off, tl);\r\n      else {\r\n        var bfr = UPNG.decode._inflate(data.slice(off,off+tl));\r\n        text = bin.readUTF8(bfr,0,bfr.length);\r\n      }\r\n      out.tabs[type][keyw] = text;\r\n    }\r\n    else if(type==\"PLTE\") {\r\n      out.tabs[type] = bin.readBytes(data, offset, len);\r\n    }\r\n    else if(type==\"hIST\") {\r\n      var pl = out.tabs[\"PLTE\"].length/3;\r\n      out.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));\r\n    }\r\n    else if(type==\"tRNS\") {\r\n      if     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);\r\n      else if(out.ctype==0) out.tabs[type] = rUs(data, offset);\r\n      else if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];\r\n      //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\r\n    }\r\n    else if(type==\"gAMA\") out.tabs[type] = bin.readUint(data, offset)/100000;\r\n    else if(type==\"sRGB\") out.tabs[type] = data[offset];\r\n    else if(type==\"bKGD\")\r\n    {\r\n      if     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];\r\n      else if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];\r\n      else if(out.ctype==3) out.tabs[type] = data[offset];\r\n    }\r\n    else if(type==\"IEND\") {\r\n      break;\r\n    }\r\n    //else {  log(\"unknown chunk type\", type, len);  }\r\n    offset += len;\r\n    var crc = bin.readUint(data, offset);  offset += 4;\r\n  }\r\n  if(foff!=0) {  var fr = out.frames[out.frames.length-1];\r\n    fr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\r\n  }\r\n  out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\r\n\r\n  delete out.compress;  delete out.interlace;  delete out.filter;\r\n  return out;\r\n}\r\n\r\nUPNG.decode._decompress = function(out, dd, w, h) {\r\n  var time = Date.now();\r\n  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), buff = new Uint8Array((bpl+1+out.interlace)*h);\r\n  if(out.tabs[\"CgBI\"]) dd = UPNG.inflateRaw(dd,buff);\r\n  else                 dd = UPNG.decode._inflate(dd,buff);\r\n  //console.log(dd.length, buff.length);\r\n  //console.log(Date.now()-time);\r\n\r\n  var time=Date.now();\r\n  if     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\r\n  else if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);\r\n  //console.log(Date.now()-time);\r\n  return dd;\r\n}\r\n\r\nUPNG.decode._inflate = function(data, buff) {  var out=UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2,data.length-6),buff);  return out;  }\r\nUPNG.inflateRaw=function(){var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\r\n  if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\r\n  if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\r\n    var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\r\n    w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\r\n    h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\r\n                                                                                                    c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\r\n    d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\r\n    I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\r\n    if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\r\n    d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\r\n  H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\r\n  H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\r\n    if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\r\n      n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\r\n    while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\r\n  H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\r\n    var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\r\n      b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\r\n    while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\r\n                                                                                             n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\r\n  H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\r\n  H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\r\n  H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\r\n    return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\r\n  (function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\r\n    V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\r\n    N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\r\n    N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\r\n    H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\r\n    n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\r\n\r\n\r\nUPNG.decode._readInterlace = function(data, out)\r\n{\r\n  var w = out.width, h = out.height;\r\n  var bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);\r\n  var img = new Uint8Array( h * bpl );\r\n  var di = 0;\r\n\r\n  var starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];\r\n  var starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];\r\n  var row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];\r\n  var col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];\r\n\r\n  var pass=0;\r\n  while(pass<7)\r\n  {\r\n    var ri = row_increment[pass], ci = col_increment[pass];\r\n    var sw = 0, sh = 0;\r\n    var cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }\r\n    var cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }\r\n    var bpll = Math.ceil(sw*bpp/8);\r\n    UPNG.decode._filterZero(data, out, di, sw, sh);\r\n\r\n    var y=0, row = starting_row[pass];\r\n    while(row<h)\r\n    {\r\n      var col = starting_col[pass];\r\n      var cdi = (di+y*bpll)<<3;\r\n\r\n      while(col<w)\r\n      {\r\n        if(bpp==1) {\r\n          var val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;\r\n          img[row*bpl + (col>>3)] |= (val << (7-((col&7)<<0)));\r\n        }\r\n        if(bpp==2) {\r\n          var val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;\r\n          img[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));\r\n        }\r\n        if(bpp==4) {\r\n          var val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;\r\n          img[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));\r\n        }\r\n        if(bpp>=8) {\r\n          var ii = row*bpl+col*cbpp;\r\n          for(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];\r\n        }\r\n        cdi+=bpp;  col+=ci;\r\n      }\r\n      y++;  row += ri;\r\n    }\r\n    if(sw*sh!=0) di += sh * (1 + bpll);\r\n    pass = pass + 1;\r\n  }\r\n  return img;\r\n}\r\n\r\nUPNG.decode._getBPP = function(out) {\r\n  var noc = [1,null,3,1,2,null,4][out.ctype];\r\n  return noc * out.depth;\r\n}\r\n\r\nUPNG.decode._filterZero = function(data, out, off, w, h)\r\n{\r\n  var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;\r\n  bpp = Math.ceil(bpp/8);\r\n\r\n  var i=0, di=1, type=data[off], x=0;\r\n\r\n  if(type>1) data[off]=[0,0,1][type-2];\r\n  if(type==3) for(x=bpp; x<bpl; x++) data[x+1] = (data[x+1] + (data[x+1-bpp]>>>1) )&255;\r\n\r\n  for(var y=0; y<h; y++)  {\r\n    i = off+y*bpl; di = i+y+1;\r\n    type = data[di-1]; x=0;\r\n\r\n    if     (type==0)   for(; x<bpl; x++) data[i+x] = data[di+x];\r\n    else if(type==1) { for(; x<bpp; x++) data[i+x] = data[di+x];\r\n      for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp]);  }\r\n    else if(type==2) { for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl]);  }\r\n    else if(type==3) { for(; x<bpp; x++) data[i+x] = (data[di+x] + ( data[i+x-bpl]>>>1));\r\n      for(; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>>1) );  }\r\n    else             { for(; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0));\r\n      for(; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) );  }\r\n  }\r\n  return data;\r\n}\r\n\r\nUPNG.decode._paeth = function(a,b,c)\r\n{\r\n  var p = a+b-c, pa = (p-a), pb = (p-b), pc = (p-c);\r\n  if (pa*pa <= pb*pb && pa*pa <= pc*pc)  return a;\r\n  else if (pb*pb <= pc*pc)  return b;\r\n  return c;\r\n}\r\n\r\nUPNG.decode._IHDR = function(data, offset, out)\r\n{\r\n  var bin = UPNG._bin;\r\n  out.width  = bin.readUint(data, offset);  offset += 4;\r\n  out.height = bin.readUint(data, offset);  offset += 4;\r\n  out.depth     = data[offset];  offset++;\r\n  out.ctype     = data[offset];  offset++;\r\n  out.compress  = data[offset];  offset++;\r\n  out.filter    = data[offset];  offset++;\r\n  out.interlace = data[offset];  offset++;\r\n}\r\n\r\nUPNG._bin = {\r\n  nextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },\r\n  readUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },\r\n  writeUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },\r\n  readUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },\r\n  writeUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },\r\n  readASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\r\n  writeASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\r\n  readBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },\r\n  pad : function(n) { return n.length < 2 ? \"0\" + n : n; },\r\n  readUTF8 : function(buff, p, l) {\r\n    var s = \"\", ns;\r\n    for(var i=0; i<l; i++) s += \"%\" + UPNG._bin.pad(buff[p+i].toString(16));\r\n    try {  ns = decodeURIComponent(s); }\r\n    catch(e) {  return UPNG._bin.readASCII(buff, p, l);  }\r\n    return  ns;\r\n  }\r\n}\r\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)\r\n{\r\n  var w = Math.min(sw,tw), h = Math.min(sh,th);\r\n  var si=0, ti=0;\r\n  for(var y=0; y<h; y++)\r\n    for(var x=0; x<w; x++)\r\n    {\r\n      if(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }\r\n      else                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }\r\n\r\n      if     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }\r\n      else if(mode==1) {\r\n        var fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa;\r\n        var ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba;\r\n\r\n        var ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);\r\n        tb[ti+3] = 255*oa;\r\n        tb[ti+0] = (fr+br*ifa)*ioa;\r\n        tb[ti+1] = (fg+bg*ifa)*ioa;\r\n        tb[ti+2] = (fb+bb*ifa)*ioa;\r\n      }\r\n      else if(mode==2){\t// copy only differences, otherwise zero\r\n        var fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2];\r\n        var ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2];\r\n        if(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }\r\n        else {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }\r\n      }\r\n      else if(mode==3){\t// check if can be blended\r\n        var fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2];\r\n        var ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2];\r\n        if(fa==ba && fr==br && fg==bg && fb==bb) continue;\r\n        //if(fa!=255 && ba!=0) return false;\r\n        if(fa<220 && ba>20) return false;\r\n      }\r\n    }\r\n  return true;\r\n}\r\n\r\n\r\n\r\n\r\nUPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte)\r\n{\r\n  if(ps==null) ps=0;\r\n  if(forbidPlte==null) forbidPlte = false;\r\n\r\n  var nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);\r\n  UPNG.encode.compressPNG(nimg, -1);\r\n\r\n  return UPNG.encode._main(nimg, w, h, dels, tabs);\r\n}\r\n\r\nUPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {\r\n  var nimg = {  ctype: 0 + (cc==1 ? 0 : 2) + (ac==0 ? 0 : 4),      depth: depth,  frames: []  };\r\n\r\n  var time = Date.now();\r\n  var bipp = (cc+ac)*depth, bipl = bipp * w;\r\n  for(var i=0; i<bufs.length; i++)\r\n    nimg.frames.push({  rect:{x:0,y:0,width:w,height:h},  img:new Uint8Array(bufs[i]), blend:0, dispose:1, bpp:Math.ceil(bipp/8), bpl:Math.ceil(bipl/8)  });\r\n\r\n  UPNG.encode.compressPNG(nimg, 0, true);\r\n\r\n  var out = UPNG.encode._main(nimg, w, h, dels, tabs);\r\n  return out;\r\n}\r\n\r\nUPNG.encode._main = function(nimg, w, h, dels, tabs) {\r\n  if(tabs==null) tabs={};\r\n  var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;\r\n  var offset = 8, anim = nimg.frames.length>1, pltAlpha = false;\r\n\r\n  var leng = 8 + (16+5+4) /*+ (9+4)*/ + (anim ? 20 : 0);\r\n  if(tabs[\"sRGB\"]!=null) leng += 8+1+4;\r\n  if(tabs[\"pHYs\"]!=null) leng += 8+9+4;\r\n  if(nimg.ctype==3) {\r\n    var dl = nimg.plte.length;\r\n    for(var i=0; i<dl; i++) if((nimg.plte[i]>>>24)!=255) pltAlpha = true;\r\n    leng += (8 + dl*3 + 4) + (pltAlpha ? (8 + dl*1 + 4) : 0);\r\n  }\r\n  for(var j=0; j<nimg.frames.length; j++)\r\n  {\r\n    var fr = nimg.frames[j];\r\n    if(anim) leng += 38;\r\n    leng += fr.cimg.length + 12;\r\n    if(j!=0) leng+=4;\r\n  }\r\n  leng += 12;\r\n\r\n  var data = new Uint8Array(leng);\r\n  var wr=[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\r\n  for(var i=0; i<8; i++) data[i]=wr[i];\r\n\r\n  wUi(data,offset, 13);     offset+=4;\r\n  wAs(data,offset,\"IHDR\");  offset+=4;\r\n  wUi(data,offset,w);  offset+=4;\r\n  wUi(data,offset,h);  offset+=4;\r\n  data[offset] = nimg.depth;  offset++;  // depth\r\n  data[offset] = nimg.ctype;  offset++;  // ctype\r\n  data[offset] = 0;  offset++;  // compress\r\n  data[offset] = 0;  offset++;  // filter\r\n  data[offset] = 0;  offset++;  // interlace\r\n  wUi(data,offset,crc(data,offset-17,17));  offset+=4; // crc\r\n\r\n  // 13 bytes to say, that it is sRGB\r\n  if(tabs[\"sRGB\"]!=null) {\r\n    wUi(data,offset, 1);      offset+=4;\r\n    wAs(data,offset,\"sRGB\");  offset+=4;\r\n    data[offset] = tabs[\"sRGB\"];  offset++;\r\n    wUi(data,offset,crc(data,offset-5,5));  offset+=4; // crc\r\n  }\r\n  if(tabs[\"pHYs\"]!=null) {\r\n    wUi(data,offset, 9);      offset+=4;\r\n    wAs(data,offset,\"pHYs\");  offset+=4;\r\n    wUi(data,offset, tabs[\"pHYs\"][0]);      offset+=4;\r\n    wUi(data,offset, tabs[\"pHYs\"][1]);      offset+=4;\r\n    data[offset]=tabs[\"pHYs\"][2];\t\t\toffset++;\r\n    wUi(data,offset,crc(data,offset-13,13));  offset+=4; // crc\r\n  }\r\n\r\n  if(anim) {\r\n    wUi(data,offset, 8);      offset+=4;\r\n    wAs(data,offset,\"acTL\");  offset+=4;\r\n    wUi(data,offset, nimg.frames.length);     offset+=4;\r\n    wUi(data,offset, tabs[\"loop\"]!=null?tabs[\"loop\"]:0);      offset+=4;\r\n    wUi(data,offset,crc(data,offset-12,12));  offset+=4; // crc\r\n  }\r\n\r\n  if(nimg.ctype==3) {\r\n    var dl = nimg.plte.length;\r\n    wUi(data,offset, dl*3);  offset+=4;\r\n    wAs(data,offset,\"PLTE\");  offset+=4;\r\n    for(var i=0; i<dl; i++){\r\n      var ti=i*3, c=nimg.plte[i], r=(c)&255, g=(c>>>8)&255, b=(c>>>16)&255;\r\n      data[offset+ti+0]=r;  data[offset+ti+1]=g;  data[offset+ti+2]=b;\r\n    }\r\n    offset+=dl*3;\r\n    wUi(data,offset,crc(data,offset-dl*3-4,dl*3+4));  offset+=4; // crc\r\n\r\n    if(pltAlpha) {\r\n      wUi(data,offset, dl);  offset+=4;\r\n      wAs(data,offset,\"tRNS\");  offset+=4;\r\n      for(var i=0; i<dl; i++)  data[offset+i]=(nimg.plte[i]>>>24)&255;\r\n      offset+=dl;\r\n      wUi(data,offset,crc(data,offset-dl-4,dl+4));  offset+=4; // crc\r\n    }\r\n  }\r\n\r\n  var fi = 0;\r\n  for(var j=0; j<nimg.frames.length; j++)\r\n  {\r\n    var fr = nimg.frames[j];\r\n    if(anim) {\r\n      wUi(data, offset, 26);     offset+=4;\r\n      wAs(data, offset,\"fcTL\");  offset+=4;\r\n      wUi(data, offset, fi++);   offset+=4;\r\n      wUi(data, offset, fr.rect.width );   offset+=4;\r\n      wUi(data, offset, fr.rect.height);   offset+=4;\r\n      wUi(data, offset, fr.rect.x);   offset+=4;\r\n      wUi(data, offset, fr.rect.y);   offset+=4;\r\n      wUs(data, offset, dels[j]);   offset+=2;\r\n      wUs(data, offset,  1000);   offset+=2;\r\n      data[offset] = fr.dispose;  offset++;\t// dispose\r\n      data[offset] = fr.blend  ;  offset++;\t// blend\r\n      wUi(data,offset,crc(data,offset-30,30));  offset+=4; // crc\r\n    }\r\n\r\n    var imgd = fr.cimg, dl = imgd.length;\r\n    wUi(data,offset, dl+(j==0?0:4));     offset+=4;\r\n    var ioff = offset;\r\n    wAs(data,offset,(j==0)?\"IDAT\":\"fdAT\");  offset+=4;\r\n    if(j!=0) {  wUi(data, offset, fi++);  offset+=4;  }\r\n    data.set(imgd,offset);\r\n    offset += dl;\r\n    wUi(data,offset,crc(data,ioff,offset-ioff));  offset+=4; // crc\r\n  }\r\n\r\n  wUi(data,offset, 0);     offset+=4;\r\n  wAs(data,offset,\"IEND\");  offset+=4;\r\n  wUi(data,offset,crc(data,offset-4,4));  offset+=4; // crc\r\n\r\n  return data.buffer;\r\n}\r\n\r\nUPNG.encode.compressPNG = function(out, filter, levelZero) {\r\n  for(var i=0; i<out.frames.length; i++) {\r\n    var frm = out.frames[i], nw=frm.rect.width, nh=frm.rect.height;\r\n    var fdata = new Uint8Array(nh*frm.bpl+nh);\r\n    frm.cimg = UPNG.encode._filterZero(frm.img,nh,frm.bpp,frm.bpl,fdata, filter, levelZero);\r\n  }\r\n}\r\n\r\n\r\n\r\nUPNG.encode.compress = function(bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte\r\n{\r\n  //var time = Date.now();\r\n  var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];\r\n\r\n  var ctype = 6, depth = 8, alphaAnd=255\r\n\r\n  for(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\r\n    var img = new Uint8Array(bufs[j]), ilen = img.length;\r\n    for(var i=0; i<ilen; i+=4) alphaAnd &= img[i+3];\r\n  }\r\n  var gotAlpha = (alphaAnd!=255);\r\n\r\n  //console.log(\"alpha check\", Date.now()-time);  time = Date.now();\r\n\r\n  //var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\r\n  var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\r\n  //console.log(\"framize\", Date.now()-time);  time = Date.now();\r\n\r\n  var cmap={}, plte=[], inds=[];\r\n\r\n  if(ps!=0) {\r\n    var nbufs = [];  for(var i=0; i<frms.length; i++) nbufs.push(frms[i].img.buffer);\r\n\r\n    var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);  //console.log(qres);\r\n    var cof = 0, bb = new Uint8Array(qres.abuf);\r\n    for(var i=0; i<frms.length; i++) {  var ti=frms[i].img, bln=ti.length;  inds.push(new Uint8Array(qres.inds.buffer, cof>>2, bln>>2));\r\n      for(var j=0; j<bln; j+=4) {  ti[j]=bb[cof+j];  ti[j+1]=bb[cof+j+1];  ti[j+2]=bb[cof+j+2];  ti[j+3]=bb[cof+j+3];  }    cof+=bln;  }\r\n\r\n    for(var i=0; i<qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);\r\n    //console.log(\"quantize\", Date.now()-time);  time = Date.now();\r\n  }\r\n  else {\r\n    // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\r\n    for(var j=0; j<frms.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\r\n      var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw=frm.rect.width, ilen = img32.length;\r\n      var ind = new Uint8Array(ilen);  inds.push(ind);\r\n      for(var i=0; i<ilen; i++) {\r\n        var c = img32[i];\r\n        if     (i!=0 && c==img32[i- 1]) ind[i]=ind[i-1];\r\n        else if(i>nw && c==img32[i-nw]) ind[i]=ind[i-nw];\r\n        else {\r\n          var cmc = cmap[c];\r\n          if(cmc==null) {  cmap[c]=cmc=plte.length;  plte.push(c);  if(plte.length>=300) break;  }\r\n          ind[i]=cmc;\r\n        }\r\n      }\r\n    }\r\n    //console.log(\"make palette\", Date.now()-time);  time = Date.now();\r\n  }\r\n\r\n  var cc=plte.length; //console.log(\"colors:\",cc);\r\n  if(cc<=256 && forbidPlte==false) {\r\n    if(cc<= 2) depth=1;  else if(cc<= 4) depth=2;  else if(cc<=16) depth=4;  else depth=8;\r\n    depth =  Math.max(depth, minBits);\r\n  }\r\n\r\n  for(var j=0; j<frms.length; j++)\r\n  {\r\n    var frm = frms[j], nx=frm.rect.x, ny=frm.rect.y, nw=frm.rect.width, nh=frm.rect.height;\r\n    var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);\r\n    var bpl = 4*nw, bpp=4;\r\n    if(cc<=256 && forbidPlte==false) {\r\n      bpl = Math.ceil(depth*nw/8);\r\n      var nimg = new Uint8Array(bpl*nh);\r\n      var inj = inds[j];\r\n      for(var y=0; y<nh; y++) {  var i=y*bpl, ii=y*nw;\r\n        if     (depth==8) for(var x=0; x<nw; x++) nimg[i+(x)   ]   =  (inj[ii+x]             );\r\n        else if(depth==4) for(var x=0; x<nw; x++) nimg[i+(x>>1)]  |=  (inj[ii+x]<<(4-(x&1)*4));\r\n        else if(depth==2) for(var x=0; x<nw; x++) nimg[i+(x>>2)]  |=  (inj[ii+x]<<(6-(x&3)*2));\r\n        else if(depth==1) for(var x=0; x<nw; x++) nimg[i+(x>>3)]  |=  (inj[ii+x]<<(7-(x&7)*1));\r\n      }\r\n      cimg=nimg;  ctype=3;  bpp=1;\r\n    }\r\n    else if(gotAlpha==false && frms.length==1) {\t// some next \"reduced\" frames may contain alpha for blending\r\n      var nimg = new Uint8Array(nw*nh*3), area=nw*nh;\r\n      for(var i=0; i<area; i++) { var ti=i*3, qi=i*4;  nimg[ti]=cimg[qi];  nimg[ti+1]=cimg[qi+1];  nimg[ti+2]=cimg[qi+2];  }\r\n      cimg=nimg;  ctype=2;  bpp=3;  bpl=3*nw;\r\n    }\r\n    frm.img=cimg;  frm.bpl=bpl;  frm.bpp=bpp;\r\n  }\r\n  //console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\r\n\r\n  return {ctype:ctype, depth:depth, plte:plte, frames:frms  };\r\n}\r\nUPNG.encode.framize = function(bufs,w,h,alwaysBlend,evenCrd,forbidPrev) {\r\n  /*  DISPOSE\r\n      - 0 : no change\r\n    - 1 : clear to transparent\r\n    - 2 : retstore to content before rendering (previous frame disposed)\r\n    BLEND\r\n    - 0 : replace\r\n    - 1 : blend\r\n  */\r\n  var frms = [];\r\n  for(var j=0; j<bufs.length; j++) {\r\n    var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\r\n    var nimg;\r\n\r\n    var nx=0, ny=0, nw=w, nh=h, blend=alwaysBlend?1:0;\r\n    if(j!=0) {\r\n      var tlim = (forbidPrev || alwaysBlend || j==1 || frms[j-2].dispose!=0)?1:2, tstp = 0, tarea = 1e9;\r\n      for(var it=0; it<tlim; it++)\r\n      {\r\n        var pimg = new Uint8Array(bufs[j-1-it]), p32 = new Uint32Array(bufs[j-1-it]);\r\n        var mix=w,miy=h,max=-1,may=-1;\r\n        for(var y=0; y<h; y++) for(var x=0; x<w; x++) {\r\n          var i = y*w+x;\r\n          if(cimg32[i]!=p32[i]) {\r\n            if(x<mix) mix=x;  if(x>max) max=x;\r\n            if(y<miy) miy=y;  if(y>may) may=y;\r\n          }\r\n        }\r\n        if(max==-1) mix=miy=max=may=0;\r\n        if(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }\r\n        var sarea = (max-mix+1)*(may-miy+1);\r\n        if(sarea<tarea) {\r\n          tarea = sarea;  tstp = it;\r\n          nx = mix; ny = miy; nw = max-mix+1; nh = may-miy+1;\r\n        }\r\n      }\r\n\r\n      // alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\r\n      var pimg = new Uint8Array(bufs[j-1-tstp]);\r\n      if(tstp==1) frms[j-1].dispose = 2;\r\n\r\n      nimg = new Uint8Array(nw*nh*4);\r\n      UPNG._copyTile(pimg,w,h, nimg,nw,nh, -nx,-ny, 0);\r\n\r\n      blend =  UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 3) ? 1 : 0;\r\n      if(blend==1) UPNG.encode._prepareDiff(cimg,w,h,nimg,{x:nx,y:ny,width:nw,height:nh});\r\n      else         UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 0);\r\n      //UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\r\n    }\r\n    else nimg = cimg.slice(0);\t// img may be rewritten further ... don't rewrite input\r\n\r\n    frms.push({rect:{x:nx,y:ny,width:nw,height:nh}, img:nimg, blend:blend, dispose:0});\r\n  }\r\n\r\n\r\n  if(alwaysBlend) for(var j=0; j<frms.length; j++) {\r\n    var frm = frms[j];  if(frm.blend==1) continue;\r\n    var r0 = frm.rect, r1 = frms[j-1].rect\r\n    var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);\r\n    var maX = Math.max(r0.x+r0.width, r1.x+r1.width), maY = Math.max(r0.y+r0.height, r1.y+r1.height);\r\n    var r = {x:miX, y:miY, width:maX-miX, height:maY-miY};\r\n\r\n    frms[j-1].dispose = 1;\r\n    if(j-1!=0)\r\n      UPNG.encode._updateFrame(bufs, w,h,frms, j-1,r, evenCrd);\r\n    UPNG.encode._updateFrame(bufs, w,h,frms, j  ,r, evenCrd);\r\n  }\r\n  var area = 0;\r\n  if(bufs.length!=1) for(var i=0; i<frms.length; i++) {\r\n    var frm = frms[i];\r\n    area += frm.rect.width*frm.rect.height;\r\n    //if(i==0 || frm.blend!=1) continue;\r\n    //var ob = new Uint8Array(\r\n    //console.log(frm.blend, frm.dispose, frm.rect);\r\n  }\r\n  //if(area!=0) console.log(area);\r\n  return frms;\r\n}\r\nUPNG.encode._updateFrame = function(bufs, w,h, frms, i, r, evenCrd) {\r\n  var U8 = Uint8Array, U32 = Uint32Array;\r\n  var pimg = new U8(bufs[i-1]), pimg32 = new U32(bufs[i-1]), nimg = i+1<bufs.length ? new U8(bufs[i+1]):null;\r\n  var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);\r\n\r\n  var mix=w,miy=h,max=-1,may=-1;\r\n  for(var y=0; y<r.height; y++) for(var x=0; x<r.width; x++) {\r\n    var cx = r.x+x, cy = r.y+y;\r\n    var j = cy*w+cx, cc = cimg32[j];\r\n    // no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\r\n    if(cc==0 || (frms[i-1].dispose==0 && pimg32[j]==cc && (nimg==null || nimg[j*4+3]!=0))/**/) {}\r\n    else {\r\n      if(cx<mix) mix=cx;  if(cx>max) max=cx;\r\n      if(cy<miy) miy=cy;  if(cy>may) may=cy;\r\n    }\r\n  }\r\n  if(max==-1) mix=miy=max=may=0;\r\n  if(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }\r\n  r = {x:mix, y:miy, width:max-mix+1, height:may-miy+1};\r\n\r\n  var fr = frms[i];  fr.rect = r;  fr.blend = 1;  fr.img = new Uint8Array(r.width*r.height*4);\r\n  if(frms[i-1].dispose==0) {\r\n    UPNG._copyTile(pimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);\r\n    UPNG.encode._prepareDiff(cimg,w,h,fr.img,r);\r\n    //UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\r\n  }\r\n  else\r\n    UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);\r\n}\r\nUPNG.encode._prepareDiff = function(cimg, w,h, nimg, rec) {\r\n  UPNG._copyTile(cimg,w,h, nimg,rec.width,rec.height, -rec.x,-rec.y, 2);\r\n  /*\r\n  var n32 = new Uint32Array(nimg.buffer);\r\n  var og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\r\n  UPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\r\n  for(var i=4; i<nimg.length; i+=4) {\r\n    if(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\r\n      n32[i>>>2]=o32[i>>>2];\r\n      //var j = i, c=p32[(i>>>2)-1];\r\n      //while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\r\n    }\r\n  }\r\n  for(var i=nimg.length-8; i>0; i-=4) {\r\n    if(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\r\n      n32[i>>>2]=o32[i>>>2];\r\n      //var j = i, c=p32[(i>>>2)-1];\r\n      //while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\r\n    }\r\n  }*/\r\n}\r\n\r\nUPNG.encode._filterZero = function(img,h,bpp,bpl,data, filter, levelZero)\r\n{\r\n  var fls = [], ftry=[0,1,2,3,4];\r\n  if     (filter!=-1)             ftry=[filter];\r\n  else if(h*bpl>500000 || bpp==1) ftry=[0];\r\n  var opts;  if(levelZero) opts={level:0};\r\n\r\n\r\n  // var CMPR = (data.length>10e6 && typeof UZIP !== 'undefined') ? UZIP : pako;\r\n  var CMPR = UZIP;\r\n\r\n  var time = Date.now();\r\n  for(var i=0; i<ftry.length; i++) {\r\n    for(var y=0; y<h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);\r\n    //var nimg = new Uint8Array(data.length);\r\n    //var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\r\n    //var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\r\n    //var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\r\n    //console.log(crc, UZIP.adler(data,2,data.length-6));\r\n    fls.push(CMPR[\"deflate\"](data,opts));\r\n  }\r\n\r\n  var ti, tsize=1e9;\r\n  for(var i=0; i<fls.length; i++) if(fls[i].length<tsize) {  ti=i;  tsize=fls[i].length;  }\r\n  return fls[ti];\r\n}\r\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type)\r\n{\r\n  var i = y*bpl, di = i+y, paeth = UPNG.decode._paeth\r\n  data[di]=type;  di++;\r\n\r\n  if(type==0) {\r\n    if(bpl<500) for(var x=0; x<bpl; x++) data[di+x] = img[i+x];\r\n    else data.set(new Uint8Array(img.buffer,i,bpl),di);\r\n  }\r\n  else if(type==1) {\r\n    for(var x=  0; x<bpp; x++) data[di+x] =  img[i+x];\r\n    for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]-img[i+x-bpp]+256)&255;\r\n  }\r\n  else if(y==0) {\r\n    for(var x=  0; x<bpp; x++) data[di+x] = img[i+x];\r\n\r\n    if(type==2) for(var x=bpp; x<bpl; x++) data[di+x] = img[i+x];\r\n    if(type==3) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - (img[i+x-bpp]>>1) +256)&255;\r\n    if(type==4) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - paeth(img[i+x-bpp], 0, 0) +256)&255;\r\n  }\r\n  else {\r\n    if(type==2) { for(var x=  0; x<bpl; x++) data[di+x] = (img[i+x]+256 - img[i+x-bpl])&255;  }\r\n    if(type==3) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - (img[i+x-bpl]>>1))&255;\r\n      for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - ((img[i+x-bpl]+img[i+x-bpp])>>1))&255;  }\r\n    if(type==4) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - paeth(0, img[i+x-bpl], 0))&255;\r\n      for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - paeth(img[i+x-bpp], img[i+x-bpl], img[i+x-bpp-bpl]))&255;  }\r\n  }\r\n}\r\n\r\nUPNG.crc = {\r\n  table : ( function() {\r\n    var tab = new Uint32Array(256);\r\n    for (var n=0; n<256; n++) {\r\n      var c = n;\r\n      for (var k=0; k<8; k++) {\r\n        if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n        else        c = c >>> 1;\r\n      }\r\n      tab[n] = c;  }\r\n    return tab;  })(),\r\n  update : function(c, buf, off, len) {\r\n    for (var i=0; i<len; i++)  c = UPNG.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n    return c;\r\n  },\r\n  crc : function(b,o,l)  {  return UPNG.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n}\r\n\r\n\r\nUPNG.quantize = function(abuf, ps)\r\n{\r\n  var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);\r\n\r\n  var KD = UPNG.quantize.getKDtree(nimg, ps);\r\n  var root = KD[0], leafs = KD[1];\r\n\r\n  var planeDst = UPNG.quantize.planeDst;\r\n  var sb = oimg, tb = nimg32, len=sb.length;\r\n\r\n  var inds = new Uint8Array(oimg.length>>2), nd;\r\n  if(oimg.length<20e6)  // precise, but slow :(\r\n    for(var i=0; i<len; i+=4) {\r\n      var r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);\r\n\r\n      nd = UPNG.quantize.getNearest(root, r, g, b, a);\r\n      inds[i>>2] = nd.ind;  tb[i>>2] = nd.est.rgba;\r\n    }\r\n  else\r\n    for(var i=0; i<len; i+=4) {\r\n      var r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);\r\n\r\n      nd = root;  while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\r\n      inds[i>>2] = nd.ind;  tb[i>>2] = nd.est.rgba;\r\n    }\r\n  return {  abuf:nimg.buffer, inds:inds, plte:leafs  };\r\n}\r\n\r\nUPNG.quantize.getKDtree = function(nimg, ps, err) {\r\n  if(err==null) err = 0.0001;\r\n  var nimg32 = new Uint32Array(nimg.buffer);\r\n\r\n  var root = {i0:0, i1:nimg.length, bst:null, est:null, tdst:0, left:null, right:null };  // basic statistic, extra statistic\r\n  root.bst = UPNG.quantize.stats(  nimg,root.i0, root.i1  );  root.est = UPNG.quantize.estats( root.bst );\r\n  var leafs = [root];\r\n\r\n  while(leafs.length<ps)\r\n  {\r\n    var maxL = 0, mi=0;\r\n    for(var i=0; i<leafs.length; i++) if(leafs[i].est.L > maxL) {  maxL=leafs[i].est.L;  mi=i;  }\r\n    if(maxL<err) break;\r\n    var node = leafs[mi];\r\n\r\n    var s0 = UPNG.quantize.splitPixels(nimg,nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\r\n    var s0wrong = (node.i0>=s0 || node.i1<=s0);\r\n    //console.log(maxL, leafs.length, mi);\r\n    if(s0wrong) {  node.est.L=0;  continue;  }\r\n\r\n\r\n    var ln = {i0:node.i0, i1:s0, bst:null, est:null, tdst:0, left:null, right:null };  ln.bst = UPNG.quantize.stats( nimg, ln.i0, ln.i1 );\r\n    ln.est = UPNG.quantize.estats( ln.bst );\r\n    var rn = {i0:s0, i1:node.i1, bst:null, est:null, tdst:0, left:null, right:null };  rn.bst = {R:[], m:[], N:node.bst.N-ln.bst.N};\r\n    for(var i=0; i<16; i++) rn.bst.R[i] = node.bst.R[i]-ln.bst.R[i];\r\n    for(var i=0; i< 4; i++) rn.bst.m[i] = node.bst.m[i]-ln.bst.m[i];\r\n    rn.est = UPNG.quantize.estats( rn.bst );\r\n\r\n    node.left = ln;  node.right = rn;\r\n    leafs[mi]=ln;  leafs.push(rn);\r\n  }\r\n  leafs.sort(function(a,b) {  return b.bst.N-a.bst.N;  });\r\n  for(var i=0; i<leafs.length; i++) leafs[i].ind=i;\r\n  return [root, leafs];\r\n}\r\n\r\nUPNG.quantize.getNearest = function(nd, r,g,b,a)\r\n{\r\n  if(nd.left==null) {  nd.tdst = UPNG.quantize.dist(nd.est.q,r,g,b,a);  return nd;  }\r\n  var planeDst = UPNG.quantize.planeDst(nd.est,r,g,b,a);\r\n\r\n  var node0 = nd.left, node1 = nd.right;\r\n  if(planeDst>0) {  node0=nd.right;  node1=nd.left;  }\r\n\r\n  var ln = UPNG.quantize.getNearest(node0, r,g,b,a);\r\n  if(ln.tdst<=planeDst*planeDst) return ln;\r\n  var rn = UPNG.quantize.getNearest(node1, r,g,b,a);\r\n  return rn.tdst<ln.tdst ? rn : ln;\r\n}\r\nUPNG.quantize.planeDst = function(est, r,g,b,a) {  var e = est.e;  return e[0]*r + e[1]*g + e[2]*b + e[3]*a - est.eMq;  }\r\nUPNG.quantize.dist     = function(q,   r,g,b,a) {  var d0=r-q[0], d1=g-q[1], d2=b-q[2], d3=a-q[3];  return d0*d0+d1*d1+d2*d2+d3*d3;  }\r\n\r\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq)\r\n{\r\n  var vecDot = UPNG.quantize.vecDot;\r\n  i1-=4;\r\n  var shfs = 0;\r\n  while(i0<i1)\r\n  {\r\n    while(vecDot(nimg, i0, e)<=eMq) i0+=4;\r\n    while(vecDot(nimg, i1, e)> eMq) i1-=4;\r\n    if(i0>=i1) break;\r\n\r\n    var t = nimg32[i0>>2];  nimg32[i0>>2] = nimg32[i1>>2];  nimg32[i1>>2]=t;\r\n\r\n    i0+=4;  i1-=4;\r\n  }\r\n  while(vecDot(nimg, i0, e)>eMq) i0-=4;\r\n  return i0+4;\r\n}\r\nUPNG.quantize.vecDot = function(nimg, i, e)\r\n{\r\n  return nimg[i]*e[0] + nimg[i+1]*e[1] + nimg[i+2]*e[2] + nimg[i+3]*e[3];\r\n}\r\nUPNG.quantize.stats = function(nimg, i0, i1){\r\n  var R = [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];\r\n  var m = [0,0,0,0];\r\n  var N = (i1-i0)>>2;\r\n  for(var i=i0; i<i1; i+=4)\r\n  {\r\n    var r = nimg[i]*(1/255), g = nimg[i+1]*(1/255), b = nimg[i+2]*(1/255), a = nimg[i+3]*(1/255);\r\n    //var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\r\n    m[0]+=r;  m[1]+=g;  m[2]+=b;  m[3]+=a;\r\n\r\n    R[ 0] += r*r;  R[ 1] += r*g;  R[ 2] += r*b;  R[ 3] += r*a;\r\n    R[ 5] += g*g;  R[ 6] += g*b;  R[ 7] += g*a;\r\n    R[10] += b*b;  R[11] += b*a;\r\n    R[15] += a*a;\r\n  }\r\n  R[4]=R[1];  R[8]=R[2];  R[9]=R[6];  R[12]=R[3];  R[13]=R[7];  R[14]=R[11];\r\n\r\n  return {R:R, m:m, N:N};\r\n}\r\nUPNG.quantize.estats = function(stats){\r\n  var R = stats.R, m = stats.m, N = stats.N;\r\n\r\n  // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\r\n  var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = (N==0 ? 0 : 1/N);\r\n  var Rj = [\r\n    R[ 0] - m0*m0*iN,  R[ 1] - m0*m1*iN,  R[ 2] - m0*m2*iN,  R[ 3] - m0*m3*iN,\r\n    R[ 4] - m1*m0*iN,  R[ 5] - m1*m1*iN,  R[ 6] - m1*m2*iN,  R[ 7] - m1*m3*iN,\r\n    R[ 8] - m2*m0*iN,  R[ 9] - m2*m1*iN,  R[10] - m2*m2*iN,  R[11] - m2*m3*iN,\r\n    R[12] - m3*m0*iN,  R[13] - m3*m1*iN,  R[14] - m3*m2*iN,  R[15] - m3*m3*iN\r\n  ];\r\n\r\n  var A = Rj, M = UPNG.M4;\r\n  var b = [Math.random(),Math.random(),Math.random(),Math.random()], mi = 0, tmi = 0;\r\n\r\n  if(N!=0)\r\n    for(var i=0; i<16; i++) {\r\n      b = M.multVec(A, b);  tmi = Math.sqrt(M.dot(b,b));  b = M.sml(1/tmi,  b);\r\n      if(i!=0 && Math.abs(tmi-mi)<1e-9) break;  mi = tmi;\r\n    }\r\n  //b = [0,0,1,0];  mi=N;\r\n  var q = [m0*iN, m1*iN, m2*iN, m3*iN];\r\n  var eMq255 = M.dot(M.sml(255,q),b);\r\n\r\n  return {  Cov:Rj, q:q, e:b, L:mi,  eMq255:eMq255, eMq : M.dot(b,q),\r\n    rgba: (((Math.round(255*q[3])<<24) | (Math.round(255*q[2])<<16) |  (Math.round(255*q[1])<<8) | (Math.round(255*q[0])<<0))>>>0)  };\r\n}\r\nUPNG.M4 = {\r\n  multVec : function(m,v) {\r\n    return [\r\n      m[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3],\r\n      m[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3],\r\n      m[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3],\r\n      m[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3]\r\n    ];\r\n  },\r\n  dot : function(x,y) {  return  x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];  },\r\n  sml : function(a,y) {  return [a*y[0],a*y[1],a*y[2],a*y[3]];  }\r\n}\r\n\r\nUPNG.encode.concatRGBA = function(bufs) {\r\n  var tlen = 0;\r\n  for(var i=0; i<bufs.length; i++) tlen += bufs[i].byteLength;\r\n  var nimg = new Uint8Array(tlen), noff=0;\r\n  for(var i=0; i<bufs.length; i++) {\r\n    var img = new Uint8Array(bufs[i]), il = img.length;\r\n    for(var j=0; j<il; j+=4) {\r\n      var r=img[j], g=img[j+1], b=img[j+2], a = img[j+3];\r\n      if(a==0) r=g=b=0;\r\n      nimg[noff+j]=r;  nimg[noff+j+1]=g;  nimg[noff+j+2]=b;  nimg[noff+j+3]=a;  }\r\n    noff += il;\r\n  }\r\n  return nimg.buffer;\r\n}\r\n\r\nexport default UPNG\r\n","import UPNG from './UPNG'\r\n\r\nconst isBrowser = typeof window !== 'undefined' // change browser environment to support SSR\r\n\r\n// add support for cordova-plugin-file\r\nconst moduleMapper = isBrowser && window.cordova && window.cordova.require && window.cordova.require('cordova/modulemapper')\r\nexport const CustomFile = isBrowser && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'File')) || File)\r\nexport const CustomFileReader = isBrowser && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'FileReader')) || FileReader)\r\n\r\n// Check if browser supports automatic image orientation\r\n// see https://github.com/blueimp/JavaScript-Load-Image/blob/1e4df707821a0afcc11ea0720ee403b8759f3881/js/load-image-orientation.js#L37-L53\r\nexport async function isAutoOrientationInBrowser() {\r\n  if (isAutoOrientationInBrowser.result !== undefined)\r\n    return isAutoOrientationInBrowser.result\r\n\r\n  // black 2x1 JPEG, with the following meta information set:\r\n  // EXIF Orientation: 6 (Rotated 90° CCW)\r\n  const testImageURL =\r\n    'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA' +\r\n    'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA' +\r\n    'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE' +\r\n    'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x' +\r\n    'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA' +\r\n    'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q=='\r\n  const testImageFile = await getFilefromDataUrl(testImageURL, 'test.jpg', Date.now())\r\n\r\n  const testImageCanvas = (await drawFileInCanvas(testImageFile))[1]\r\n  const testImageFile2 = await canvasToFile(testImageCanvas, testImageFile.type, testImageFile.name, testImageFile.lastModified)\r\n  cleanupCanvasMemory(testImageCanvas)\r\n  const img = (await drawFileInCanvas(testImageFile2))[0]\r\n  // console.log('img', img.width, img.height)\r\n\r\n  isAutoOrientationInBrowser.result = img.width === 1 && img.height === 2\r\n  return isAutoOrientationInBrowser.result\r\n}\r\n\r\n/**\r\n * getDataUrlFromFile\r\n *\r\n * @param {File | Blob} file\r\n * @returns {Promise<string>}\r\n */\r\nexport function getDataUrlFromFile (file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new CustomFileReader()\r\n    reader.onload = () => resolve(reader.result)\r\n    reader.onerror = (e) => reject(e)\r\n    reader.readAsDataURL(file)\r\n  })\r\n}\r\n\r\n/**\r\n * getFilefromDataUrl\r\n *\r\n * @param {string} dataUrl\r\n * @param {string} filename\r\n * @param {number} [lastModified=Date.now()]\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport function getFilefromDataUrl (dataUrl, filename, lastModified = Date.now()) {\r\n  return new Promise((resolve) => {\r\n    const arr = dataUrl.split(',')\r\n    const mime = arr[0].match(/:(.*?);/)[1]\r\n    const bstr = globalThis.atob(arr[1])\r\n    let n = bstr.length\r\n    const u8arr = new Uint8Array(n)\r\n    while (n--) {\r\n      u8arr[n] = bstr.charCodeAt(n)\r\n    }\r\n    const file = new Blob([u8arr], { type: mime })\r\n    file.name = filename\r\n    file.lastModified = lastModified\r\n    resolve(file)\r\n\r\n    // Safari has issue with File constructor not being able to POST in FormData\r\n    // https://github.com/Donaldcwl/browser-image-compression/issues/8\r\n    // https://bugs.webkit.org/show_bug.cgi?id=165081\r\n    // let file\r\n    // try {\r\n    //   file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\r\n    // } catch (e) {\r\n    //   file = new Blob([u8arr], { type: mime })\r\n    //   file.name = filename\r\n    //   file.lastModified = lastModified\r\n    // }\r\n    // resolve(file)\r\n  })\r\n}\r\n\r\n/**\r\n * loadImage\r\n *\r\n * @param {string} src\r\n * @returns {Promise<HTMLImageElement>}\r\n */\r\nexport function loadImage (src) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image()\r\n    img.onload = () => resolve(img)\r\n    img.onerror = (e) => reject(e)\r\n    img.src = src\r\n  })\r\n}\r\n\r\n/**\r\n * drawImageInCanvas\r\n *\r\n * @param {HTMLImageElement} img\r\n * @returns {HTMLCanvasElement | OffscreenCanvas}\r\n */\r\nexport function drawImageInCanvas (img) {\r\n  const [canvas, ctx] = getNewCanvasAndCtx(img.width, img.height)\r\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\r\n  return canvas\r\n}\r\n\r\n/**\r\n * drawFileInCanvas\r\n *\r\n * @param {File | Blob} file\r\n * @returns {Promise<[ImageBitmap | HTMLImageElement, HTMLCanvasElement | OffscreenCanvas]>}\r\n */\r\nexport async function drawFileInCanvas (file) {\r\n  let img\r\n  try {\r\n    img = await createImageBitmap(file)\r\n  } catch (e) {\r\n    const dataUrl = await getDataUrlFromFile(file)\r\n    img = await loadImage(dataUrl)\r\n  }\r\n  const canvas = drawImageInCanvas(img)\r\n  return [img, canvas]\r\n}\r\n\r\n/**\r\n * canvasToFile\r\n *\r\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\r\n * @param {string} fileType\r\n * @param {string} fileName\r\n * @param {number} fileLastModified\r\n * @param {number} [quality]\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport async function canvasToFile (canvas, fileType, fileName, fileLastModified, quality = 1) {\r\n  let file\r\n  if (fileType === 'image/png') {\r\n    const ctx = canvas.getContext('2d')\r\n    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data\r\n    const png = UPNG.encode([data], canvas.width, canvas.height, 256 * quality)\r\n    file = new Blob([png], { type: fileType })\r\n    file.name = fileName\r\n    file.lastModified = fileLastModified\r\n  } else if (typeof OffscreenCanvas === 'function' && canvas instanceof OffscreenCanvas) { // checked on Win Chrome 83, MacOS Chrome 83\r\n    file = await canvas.convertToBlob({ type: fileType, quality })\r\n    file.name = fileName\r\n    file.lastModified = fileLastModified\r\n  // some browser do not support quality parameter, see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\r\n  // } else if (typeof canvas.toBlob === 'function') {\r\n  //   file = await new Promise(resolve => canvas.toBlob(resolve, fileType, quality))\r\n  } else { // checked on Win Edge 44, Win IE 11, Win Firefox 76, MacOS Firefox 77, MacOS Safari 13.1\r\n    const dataUrl = canvas.toDataURL(fileType, quality)\r\n    file = await getFilefromDataUrl(dataUrl, fileName, fileLastModified)\r\n  }\r\n  return file\r\n}\r\n\r\n/**\r\n * getExifOrientation\r\n * get image exif orientation info\r\n * source: https://stackoverflow.com/a/32490603/10395024\r\n *\r\n * @param {File | Blob} file\r\n * @returns {Promise<number>} - orientation id, see https://i.stack.imgur.com/VGsAj.gif\r\n */\r\nexport function getExifOrientation (file) {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new CustomFileReader()\r\n    reader.onload = (e) => {\r\n      const view = new DataView(e.target.result)\r\n      if (view.getUint16(0, false) != 0xFFD8) {\r\n        return resolve(-2)\r\n      }\r\n      const length = view.byteLength\r\n      let offset = 2\r\n      while (offset < length) {\r\n        if (view.getUint16(offset + 2, false) <= 8) return resolve(-1)\r\n        const marker = view.getUint16(offset, false)\r\n        offset += 2\r\n        if (marker == 0xFFE1) {\r\n          if (view.getUint32(offset += 2, false) != 0x45786966) {\r\n            return resolve(-1)\r\n          }\r\n\r\n          var little = view.getUint16(offset += 6, false) == 0x4949\r\n          offset += view.getUint32(offset + 4, little)\r\n          var tags = view.getUint16(offset, little)\r\n          offset += 2\r\n          for (var i = 0; i < tags; i++) {\r\n            if (view.getUint16(offset + (i * 12), little) == 0x0112) {\r\n              return resolve(view.getUint16(offset + (i * 12) + 8, little))\r\n            }\r\n          }\r\n        } else if ((marker & 0xFF00) != 0xFF00) {\r\n          break\r\n        } else {\r\n          offset += view.getUint16(offset, false)\r\n        }\r\n      }\r\n      return resolve(-1)\r\n    }\r\n    reader.onerror = (e) => reject(e)\r\n    reader.readAsArrayBuffer(file)\r\n  })\r\n}\r\n\r\n/**\r\n *\r\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\r\n * @param options\r\n * @returns {HTMLCanvasElement | OffscreenCanvas}\r\n */\r\nexport function handleMaxWidthOrHeight (canvas, options) {\r\n  const width = canvas.width\r\n  const height = canvas.height\r\n  const maxWidthOrHeight = options.maxWidthOrHeight\r\n\r\n  const needToHandle = isFinite(maxWidthOrHeight) && (width > maxWidthOrHeight || height > maxWidthOrHeight)\r\n\r\n  let newCanvas = canvas\r\n  let ctx\r\n\r\n  if (needToHandle) {\r\n    [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\r\n    if (width > height) {\r\n      newCanvas.width = maxWidthOrHeight\r\n      newCanvas.height = (height / width) * maxWidthOrHeight\r\n    } else {\r\n      newCanvas.width = (width / height) * maxWidthOrHeight\r\n      newCanvas.height = maxWidthOrHeight\r\n    }\r\n    ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height)\r\n\r\n    cleanupCanvasMemory(canvas)\r\n  }\r\n\r\n  return newCanvas\r\n}\r\n\r\n/**\r\n * followExifOrientation\r\n * source: https://stackoverflow.com/a/40867559/10395024\r\n *\r\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\r\n * @param {number} exifOrientation\r\n * @returns {HTMLCanvasElement | OffscreenCanvas} canvas\r\n */\r\nexport function followExifOrientation (canvas, exifOrientation) {\r\n  const width = canvas.width\r\n  const height = canvas.height\r\n\r\n  const [newCanvas, ctx] = getNewCanvasAndCtx(width, height)\r\n\r\n  // set proper canvas dimensions before transform & export\r\n  if (4 < exifOrientation && exifOrientation < 9) {\r\n    newCanvas.width = height\r\n    newCanvas.height = width\r\n  } else {\r\n    newCanvas.width = width\r\n    newCanvas.height = height\r\n  }\r\n\r\n  // transform context before drawing image\r\n  switch (exifOrientation) {\r\n    case 2:\r\n      ctx.transform(-1, 0, 0, 1, width, 0)\r\n      break\r\n    case 3:\r\n      ctx.transform(-1, 0, 0, -1, width, height)\r\n      break\r\n    case 4:\r\n      ctx.transform(1, 0, 0, -1, 0, height)\r\n      break\r\n    case 5:\r\n      ctx.transform(0, 1, 1, 0, 0, 0)\r\n      break\r\n    case 6:\r\n      ctx.transform(0, 1, -1, 0, height, 0)\r\n      break\r\n    case 7:\r\n      ctx.transform(0, -1, -1, 0, height, width)\r\n      break\r\n    case 8:\r\n      ctx.transform(0, -1, 1, 0, 0, width)\r\n      break\r\n    default:\r\n      break\r\n  }\r\n\r\n  ctx.drawImage(canvas, 0, 0, width, height)\r\n\r\n  cleanupCanvasMemory(canvas)\r\n\r\n  return newCanvas\r\n}\r\n\r\n/**\r\n * get new Canvas and it's context\r\n * @param width\r\n * @param height\r\n * @returns {[HTMLCanvasElement | OffscreenCanvas, CanvasRenderingContext2D]}\r\n */\r\nexport function getNewCanvasAndCtx (width, height) {\r\n  let canvas\r\n  let ctx\r\n  try {\r\n    canvas = new OffscreenCanvas(width, height)\r\n    ctx = canvas.getContext('2d')\r\n    if (ctx === null) {\r\n      throw new Error('getContext of OffscreenCanvas returns null')\r\n    }\r\n  } catch (e) {\r\n    canvas = document.createElement('canvas')\r\n    ctx = canvas.getContext('2d')\r\n  }\r\n  canvas.width = width\r\n  canvas.height = height\r\n  // ctx.fillStyle = '#fff'\r\n  // ctx.fillRect(0, 0, width, height)\r\n  return [canvas, ctx]\r\n}\r\n\r\n/**\r\n * clear Canvas memory\r\n * @param canvas\r\n * @returns null\r\n */\r\nexport function cleanupCanvasMemory (canvas) {\r\n  // garbage clean canvas for safari\r\n  // ref: https://bugs.webkit.org/show_bug.cgi?id=195325\r\n  canvas.width = 0\r\n  canvas.height = 0\r\n}\r\n\r\nif (isBrowser) {\r\n// Polyfill for Number.isInteger\r\n  Number.isInteger = Number.isInteger || function (value) {\r\n    return typeof value === 'number' &&\r\n      isFinite(value) &&\r\n      Math.floor(value) === value\r\n  }\r\n}\r\n","import {\r\n  canvasToFile,\r\n  cleanupCanvasMemory,\r\n  drawFileInCanvas,\r\n  followExifOrientation,\r\n  getExifOrientation,\r\n  getNewCanvasAndCtx,\r\n  handleMaxWidthOrHeight,\r\n  isAutoOrientationInBrowser\r\n} from './utils'\r\n\r\n/**\r\n * Compress an image file.\r\n *\r\n * @param {File} file\r\n * @param {Object} options\r\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\r\n * @param {number} [options.maxWidthOrHeight=undefined]\r\n * @param {boolean} [options.useWebWorker=false]\r\n * @param {number} [options.maxIteration=10]\r\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\r\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\r\n * @param {string} [options.fileType] - default to be the original mime type from the image file\r\n * @param {number} [options.initialQuality=1.0]\r\n * @param {number} previousProgress - for internal try catch rerunning start from previous progress\r\n * @returns {Promise<File | Blob>}\r\n */\r\nexport default async function compress (file, options, previousProgress = 0) {\r\n  let progress = previousProgress\r\n\r\n  function incProgress (inc = 5) {\r\n    progress += inc\r\n    options.onProgress(Math.min(progress, 100))\r\n  }\r\n\r\n  function setProgress (p) {\r\n    progress = Math.min(Math.max(p, progress), 100)\r\n    options.onProgress(progress)\r\n  }\r\n\r\n  let remainingTrials = options.maxIteration || 10\r\n\r\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024\r\n\r\n  incProgress()\r\n\r\n  // drawFileInCanvas\r\n  let [img, origCanvas] = await drawFileInCanvas(file)\r\n\r\n  incProgress()\r\n\r\n  // handleMaxWidthOrHeight\r\n  const maxWidthOrHeightFixedCanvas = handleMaxWidthOrHeight(origCanvas, options)\r\n\r\n  incProgress()\r\n\r\n  // exifOrientation\r\n  const exifOrientation = options.exifOrientation || await getExifOrientation(file)\r\n  incProgress()\r\n  const orientationFixedCanvas = (await isAutoOrientationInBrowser()) ? maxWidthOrHeightFixedCanvas : followExifOrientation(maxWidthOrHeightFixedCanvas, exifOrientation)\r\n  incProgress()\r\n\r\n  let quality = options.initialQuality || 1.0\r\n\r\n  const outputFileType = options.fileType || file.type\r\n\r\n  let tempFile = await canvasToFile(orientationFixedCanvas, outputFileType, file.name, file.lastModified, quality)\r\n  incProgress()\r\n\r\n  const origExceedMaxSize = tempFile.size > maxSizeByte\r\n  const sizeBecomeLarger = tempFile.size > file.size\r\n  // console.log('original file size', file.size)\r\n  // console.log('current file size', tempFile.size)\r\n\r\n  // check if we need to compress or resize\r\n  if (!origExceedMaxSize && !sizeBecomeLarger) {\r\n    // no need to compress\r\n    setProgress(100)\r\n    return tempFile\r\n  }\r\n\r\n  const sourceSize = file.size\r\n  const renderedSize = tempFile.size\r\n  let currentSize = renderedSize\r\n  let compressedFile\r\n  let newCanvas, ctx\r\n  let canvas = orientationFixedCanvas\r\n  while (remainingTrials-- && (currentSize > maxSizeByte || currentSize > sourceSize)) {\r\n    const newWidth = origExceedMaxSize ? canvas.width * 0.95 : canvas.width\r\n    const newHeight = origExceedMaxSize ? canvas.height * 0.95 : canvas.height;\r\n    // console.log('current width', newWidth);\r\n    // console.log('current height', newHeight);\r\n    [newCanvas, ctx] = getNewCanvasAndCtx(newWidth, newHeight)\r\n\r\n    ctx.drawImage(canvas, 0, 0, newWidth, newHeight)\r\n\r\n    quality *= 0.95\r\n    compressedFile = await canvasToFile(newCanvas, outputFileType, file.name, file.lastModified, quality)\r\n\r\n    cleanupCanvasMemory(canvas)\r\n\r\n    canvas = newCanvas\r\n\r\n    currentSize = compressedFile.size\r\n    // console.log('currentSize', currentSize)\r\n    setProgress(Math.min(99, Math.floor((renderedSize - currentSize) / (renderedSize - maxSizeByte) * 100)))\r\n  }\r\n\r\n  cleanupCanvasMemory(canvas)\r\n  cleanupCanvasMemory(newCanvas)\r\n  cleanupCanvasMemory(maxWidthOrHeightFixedCanvas)\r\n  cleanupCanvasMemory(orientationFixedCanvas)\r\n  cleanupCanvasMemory(origCanvas)\r\n\r\n  setProgress(100)\r\n  return compressedFile\r\n}\r\n","import lib from './index'\r\nimport compress from './image-compression'\r\nimport { cleanupCanvasMemory, getNewCanvasAndCtx } from './utils'\r\nimport UPNG from './UPNG'\r\nimport * as UZIP from 'uzip'\r\n\r\nlet cnt = 0\r\nlet imageCompressionLibUrl\r\nlet worker\r\n\r\nfunction createWorker (script) {\r\n  if (typeof script === 'function') {\r\n    script = `(${f})()`\r\n  }\r\n  return new Worker(URL.createObjectURL(new Blob([script])))\r\n}\r\n\r\nfunction createSourceObject (str) {\r\n  // console.log('createSourceObject', str)\r\n  return URL.createObjectURL(new Blob([str], { type: 'application/javascript' }))\r\n}\r\n\r\nfunction stringify(o) {\r\n  return JSON.stringify(o, (key, value) => {\r\n    return (typeof value === 'function' ) ? `BIC_FN:::(() => ${value.toString()})()` : value;\r\n  })\r\n}\r\n\r\nfunction parse(o) {\r\n  if (typeof o === 'string') return o\r\n  const result = {}\r\n  Object.entries(o).forEach(([key, value]) => {\r\n    if (typeof value === 'string' && value.startsWith('BIC_FN:::')) {\r\n      try {\r\n        result[key] = eval(value.replace(/^BIC_FN:::/, ''))\r\n      } catch (e) {\r\n        console.log(key, e)\r\n        throw e\r\n      }\r\n    } else {\r\n      result[key] = parse(value)\r\n    }\r\n  })\r\n  return result\r\n}\r\n\r\nfunction generateLib () {\r\n  // prepare the lib to be used inside WebWorker\r\n  return createSourceObject(`\r\n    // reconstruct library\r\n    function imageCompression (){return (${lib}).apply(null, arguments)}\r\n\r\n    imageCompression.getDataUrlFromFile = ${lib.getDataUrlFromFile}\r\n    imageCompression.getFilefromDataUrl = ${lib.getFilefromDataUrl}\r\n    imageCompression.loadImage = ${lib.loadImage}\r\n    imageCompression.drawImageInCanvas = ${lib.drawImageInCanvas}\r\n    imageCompression.drawFileInCanvas = ${lib.drawFileInCanvas}\r\n    imageCompression.canvasToFile = ${lib.canvasToFile}\r\n    imageCompression.getExifOrientation = ${lib.getExifOrientation}\r\n    imageCompression.handleMaxWidthOrHeight = ${lib.handleMaxWidthOrHeight}\r\n    imageCompression.followExifOrientation = ${lib.followExifOrientation}\r\n    imageCompression.cleanupCanvasMemory = ${lib.cleanupCanvasMemory}\r\n    imageCompression.isAutoOrientationInBrowser = ${lib.isAutoOrientationInBrowser}\r\n\r\n    // functions / objects\r\n    getDataUrlFromFile = imageCompression.getDataUrlFromFile\r\n    getFilefromDataUrl = imageCompression.getFilefromDataUrl\r\n    loadImage = imageCompression.loadImage\r\n    drawImageInCanvas = imageCompression.drawImageInCanvas\r\n    drawFileInCanvas = imageCompression.drawFileInCanvas\r\n    canvasToFile = imageCompression.canvasToFile\r\n    getExifOrientation = imageCompression.getExifOrientation\r\n    handleMaxWidthOrHeight = imageCompression.handleMaxWidthOrHeight\r\n    followExifOrientation = imageCompression.followExifOrientation\r\n    cleanupCanvasMemory = imageCompression.cleanupCanvasMemory\r\n    isAutoOrientationInBrowser = imageCompression.isAutoOrientationInBrowser\r\n    \r\n    getNewCanvasAndCtx = ${getNewCanvasAndCtx}\r\n    CustomFileReader = FileReader\r\n    CustomFile = File\r\n    function _slicedToArray(arr, n) { return arr }\r\n    function _typeof(a) { return typeof a }\r\n    function compress (){return (${compress}).apply(null, arguments)}\r\n\r\n    // Libraries\r\n    const parse = ${parse}\r\n    const UPNG = {}\r\n    UPNG.toRGBA8 = ${UPNG.toRGBA8}\r\n    UPNG.toRGBA8.decodeImage = ${UPNG.toRGBA8.decodeImage}\r\n    UPNG.decode = ${UPNG.decode}\r\n    UPNG.decode._decompress = ${UPNG.decode._decompress}\r\n    UPNG.decode._inflate = ${UPNG.decode._inflate}\r\n    UPNG.decode._readInterlace = ${UPNG.decode._readInterlace}\r\n    UPNG.decode._getBPP = ${UPNG.decode._getBPP} \r\n    UPNG.decode._filterZero = ${UPNG.decode._filterZero}\r\n    UPNG.decode._paeth = ${UPNG.decode._paeth}\r\n    UPNG.decode._IHDR = ${UPNG.decode._IHDR}\r\n    UPNG._bin = parse(${stringify(UPNG._bin)})\r\n    UPNG._copyTile = ${UPNG._copyTile}\r\n    UPNG.encode = ${UPNG.encode}\r\n    UPNG.encodeLL = ${UPNG.encodeLL} \r\n    UPNG.encode._main = ${UPNG.encode._main}\r\n    UPNG.encode.compressPNG = ${UPNG.encode.compressPNG} \r\n    UPNG.encode.compress = ${UPNG.encode.compress}\r\n    UPNG.encode.framize = ${UPNG.encode.framize} \r\n    UPNG.encode._updateFrame = ${UPNG.encode._updateFrame} \r\n    UPNG.encode._prepareDiff = ${UPNG.encode._prepareDiff} \r\n    UPNG.encode._filterZero = ${UPNG.encode._filterZero} \r\n    UPNG.encode._filterLine = ${UPNG.encode._filterLine}\r\n    UPNG.encode.concatRGBA = ${UPNG.encode.concatRGBA}\r\n    UPNG.crc = parse(${stringify(UPNG.crc)})\r\n    UPNG.crc.table = ( function() {\r\n    var tab = new Uint32Array(256);\r\n    for (var n=0; n<256; n++) {\r\n      var c = n;\r\n      for (var k=0; k<8; k++) {\r\n        if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n        else        c = c >>> 1;\r\n      }\r\n      tab[n] = c;  }\r\n    return tab;  })()\r\n    UPNG.quantize = ${UPNG.quantize} \r\n    UPNG.quantize.getKDtree = ${UPNG.quantize.getKDtree} \r\n    UPNG.quantize.getNearest = ${UPNG.quantize.getNearest} \r\n    UPNG.quantize.planeDst = ${UPNG.quantize.planeDst} \r\n    UPNG.quantize.dist = ${UPNG.quantize.dist}     \r\n    UPNG.quantize.splitPixels = ${UPNG.quantize.splitPixels} \r\n    UPNG.quantize.vecDot = ${UPNG.quantize.vecDot} \r\n    UPNG.quantize.stats = ${UPNG.quantize.stats} \r\n    UPNG.quantize.estats = ${UPNG.quantize.estats}\r\n    UPNG.M4 = parse(${stringify(UPNG.M4)})\r\n    UPNG.encode.concatRGBA = ${UPNG.encode.concatRGBA}\r\n    UPNG.inflateRaw=function(){\r\n    var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\r\n      if(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\r\n      if(Z)W=new R(N.length>>>2<<5);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\r\n        var D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\r\n        w+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\r\n        h=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\r\n                                                                                                        c<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\r\n        d=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\r\n        I(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\r\n        if(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\r\n        d+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\r\n      H.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\r\n      H.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\r\n        if(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\r\n          n+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\r\n        while(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\r\n      H.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\r\n        var b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\r\n          b[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\r\n        while(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\r\n                                                                                                 n+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\r\n      H.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\r\n      H.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\r\n      H.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\r\n        return{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\r\n      (function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\r\n        V=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\r\n        N.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\r\n        N.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\r\n        H.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\r\n        n(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\r\n    \r\n    const UZIP = {}\r\n    UZIP[\"parse\"] = ${UZIP[\"parse\"]}\r\n    UZIP._readLocal = ${UZIP._readLocal}\r\n    UZIP.inflateRaw = ${UZIP.inflateRaw}\r\n    UZIP.inflate = ${UZIP.inflate}\r\n    UZIP.deflate = ${UZIP.deflate}\r\n    UZIP.deflateRaw = ${UZIP.deflateRaw}\r\n    UZIP.encode = ${UZIP.encode}\r\n    UZIP._noNeed = ${UZIP._noNeed}\r\n    UZIP._writeHeader = ${UZIP._writeHeader}\r\n    UZIP.crc = parse(${stringify(UZIP.crc)})\r\n    UZIP.crc.table = ( function() {\r\n      var tab = new Uint32Array(256);\r\n      for (var n=0; n<256; n++) {\r\n        var c = n;\r\n        for (var k=0; k<8; k++) {\r\n          if (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n          else        c = c >>> 1;\r\n        }\r\n        tab[n] = c;  }\r\n      return tab;  })()\r\n    \r\n    UZIP.adler = ${UZIP.adler}\r\n    UZIP.bin = parse(${stringify(UZIP.bin)})\r\n    UZIP.F = {}\r\n    UZIP.F.deflateRaw = ${UZIP.F.deflateRaw}\r\n    UZIP.F._bestMatch = ${UZIP.F._bestMatch}\r\n    UZIP.F._howLong = ${UZIP.F._howLong}\r\n    UZIP.F._hash = ${UZIP.F._hash}\r\n    UZIP.saved = ${UZIP.saved}\r\n    UZIP.F._writeBlock = ${UZIP.F._writeBlock}\r\n    UZIP.F._copyExact = ${UZIP.F._copyExact}\r\n    UZIP.F.getTrees = ${UZIP.F.getTrees}\r\n    UZIP.F.getSecond = ${UZIP.F.getSecond}\r\n    UZIP.F.nonZero = ${UZIP.F.nonZero}\r\n    UZIP.F.contSize = ${UZIP.F.contSize}\r\n    UZIP.F._codeTiny = ${UZIP.F._codeTiny} \r\n    UZIP.F._lenCodes = ${UZIP.F._lenCodes} \r\n    UZIP.F._hufTree = ${UZIP.F._hufTree} \r\n    UZIP.F.setDepth = ${UZIP.F.setDepth} \r\n    UZIP.F.restrictDepth = ${UZIP.F.restrictDepth}\r\n    UZIP.F._goodIndex = ${UZIP.F._goodIndex} \r\n    UZIP.F._writeLit = ${UZIP.F._writeLit} \r\n    UZIP.F.inflate = ${UZIP.F.inflate} \r\n    UZIP.F._check = ${UZIP.F._check} \r\n    UZIP.F._decodeTiny = ${UZIP.F._decodeTiny} \r\n    UZIP.F._copyOut = ${UZIP.F._copyOut} \r\n    UZIP.F.makeCodes = ${UZIP.F.makeCodes} \r\n    UZIP.F.codes2map = ${UZIP.F.codes2map} \r\n    UZIP.F.revCodes = ${UZIP.F.revCodes} \r\n\r\n    // used only in deflate\r\n    UZIP.F._putsE = ${UZIP.F._putsE}\r\n    UZIP.F._putsF = ${UZIP.F._putsF}\r\n  \r\n    UZIP.F._bitsE = ${UZIP.F._bitsE}\r\n    UZIP.F._bitsF = ${UZIP.F._bitsF}\r\n\r\n    UZIP.F._get17 = ${UZIP.F._get17}\r\n    UZIP.F._get25 = ${UZIP.F._get25}\r\n    UZIP.F.U = function(){\r\n      var u16=Uint16Array, u32=Uint32Array;\r\n      return {\r\n        next_code : new u16(16),\r\n        bl_count  : new u16(16),\r\n        ordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\r\n        of0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\r\n        exb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\r\n        ldef : new u16(32),\r\n        df0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\r\n        dxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\r\n        ddef : new u32(32),\r\n        flmap: new u16(  512),  fltree: [],\r\n        fdmap: new u16(   32),  fdtree: [],\r\n        lmap : new u16(32768),  ltree : [],  ttree:[],\r\n        dmap : new u16(32768),  dtree : [],\r\n        imap : new u16(  512),  itree : [],\r\n        //rev9 : new u16(  512)\r\n        rev15: new u16(1<<15),\r\n        lhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\r\n        lits : new u32(15000),\r\n        strt : new u16(1<<16),\r\n        prev : new u16(1<<15)\r\n      };\r\n    } ();\r\n\r\n    (function(){\r\n      var U = UZIP.F.U;\r\n      var len = 1<<15;\r\n      for(var i=0; i<len; i++) {\r\n        var x = i;\r\n        x = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\r\n        x = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\r\n        x = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\r\n        x = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\r\n        U.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\r\n      }\r\n  \r\n      function pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\r\n  \r\n      for(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\r\n  \r\n      pushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\r\n      /*\r\n        var i = 0;\r\n        for(; i<=143; i++) U.fltree.push(0,8);\r\n        for(; i<=255; i++) U.fltree.push(0,9);\r\n        for(; i<=279; i++) U.fltree.push(0,7);\r\n        for(; i<=287; i++) U.fltree.push(0,8);\r\n        */\r\n      UZIP.F.makeCodes(U.fltree, 9);\r\n      UZIP.F.codes2map(U.fltree, 9, U.flmap);\r\n      UZIP.F.revCodes (U.fltree, 9)\r\n  \r\n      pushV(U.fdtree,32,5);\r\n      //for(i=0;i<32; i++) U.fdtree.push(0,5);\r\n      UZIP.F.makeCodes(U.fdtree, 5);\r\n      UZIP.F.codes2map(U.fdtree, 5, U.fdmap);\r\n      UZIP.F.revCodes (U.fdtree, 5)\r\n  \r\n      pushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\r\n      /*\r\n        for(var i=0; i< 19; i++) U.itree.push(0,0);\r\n        for(var i=0; i<286; i++) U.ltree.push(0,0);\r\n        for(var i=0; i< 30; i++) U.dtree.push(0,0);\r\n        for(var i=0; i<320; i++) U.ttree.push(0,0);\r\n        */\r\n    })()\r\n    `)\r\n}\r\n\r\nfunction generateWorkerScript () {\r\n  // code to be run in the WebWorker\r\n  return createWorker(`\r\n    let scriptImported = false\r\n    self.addEventListener('message', async (e) => {\r\n      const { file, id, imageCompressionLibUrl, options } = e.data\r\n      options.onProgress = (progress) => self.postMessage({ progress, id })\r\n      try {\r\n        if (!scriptImported) {\r\n          // console.log('[worker] importScripts', imageCompressionLibUrl)\r\n          self.importScripts(imageCompressionLibUrl)\r\n          scriptImported = true\r\n        }\r\n        // console.log('[worker] self', self)\r\n        const compressedFile = await imageCompression(file, options)\r\n        self.postMessage({ file: compressedFile, id })\r\n      } catch (e) {\r\n        // console.error('[worker] error', e)\r\n        self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\r\n      }\r\n    })\r\n  `)\r\n}\r\n\r\nexport function compressOnWebWorker (file, options) {\r\n  return new Promise(async (resolve, reject) => {\r\n    let id = cnt++\r\n\r\n    if (!imageCompressionLibUrl) {\r\n      imageCompressionLibUrl = generateLib()\r\n    }\r\n\r\n    if (!worker) {\r\n      worker = generateWorkerScript()\r\n    }\r\n\r\n    function handler (e) {\r\n      if (e.data.id === id) {\r\n        if (e.data.progress !== undefined) {\r\n          options.onProgress(e.data.progress)\r\n          return\r\n        }\r\n        worker.removeEventListener('message', handler)\r\n        if (e.data.error) {\r\n          reject(new Error(e.data.error))\r\n        }\r\n        resolve(e.data.file)\r\n      }\r\n    }\r\n\r\n    worker.addEventListener('message', handler)\r\n    worker.addEventListener('error', reject)\r\n\r\n    worker.postMessage({\r\n      file,\r\n      id,\r\n      imageCompressionLibUrl,\r\n      options: { ...options, onProgress: undefined }\r\n    })\r\n  })\r\n}\r\n","import compress from './image-compression'\r\nimport {\r\n  canvasToFile,\r\n  drawFileInCanvas,\r\n  drawImageInCanvas,\r\n  getDataUrlFromFile,\r\n  getFilefromDataUrl,\r\n  loadImage,\r\n  getExifOrientation,\r\n  handleMaxWidthOrHeight,\r\n  followExifOrientation,\r\n  CustomFile,\r\n  cleanupCanvasMemory,\r\n  isAutoOrientationInBrowser\r\n} from './utils'\r\nimport { compressOnWebWorker } from './web-worker'\r\n\r\n/**\r\n * Compress an image file.\r\n *\r\n * @param {File} file\r\n * @param {Object} options - { maxSizeMB=Number.POSITIVE_INFINITY, maxWidthOrHeight, useWebWorker=false, maxIteration = 10, exifOrientation, fileType }\r\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\r\n * @param {number} [options.maxWidthOrHeight=undefined]\r\n * @param {boolean} [options.useWebWorker=false]\r\n * @param {number} [options.maxIteration=10]\r\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\r\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\r\n * @param {string} [options.fileType] - default to be the original mime type from the image file\r\n * @returns {Promise<File | Blob>}\r\n */\r\nasync function imageCompression (file, options) {\r\n\r\n  let compressedFile\r\n  let progress = 0\r\n  let onProgress\r\n\r\n  options.maxSizeMB = options.maxSizeMB || Number.POSITIVE_INFINITY\r\n  const useWebWorker = typeof options.useWebWorker === 'boolean' ? options.useWebWorker : true\r\n  delete options.useWebWorker\r\n  onProgress = options.onProgress\r\n  options.onProgress = (aProgress) => {\r\n    progress = aProgress\r\n    if (typeof onProgress === 'function') {\r\n      onProgress(progress)\r\n    }\r\n  }\r\n\r\n  if (!(file instanceof Blob || file instanceof CustomFile)) {\r\n    throw new Error('The file given is not an instance of Blob or File')\r\n  } else if (!/^image/.test(file.type)) {\r\n    throw new Error('The file given is not an image')\r\n  }\r\n\r\n  // try run in web worker, fall back to run in main thread\r\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope\r\n\r\n  // if ((useWebWorker && typeof Worker === 'function') || inWebWorker) {\r\n  //   console.log('run compression in web worker')\r\n  // } else {\r\n  //   console.log('run compression in main thread')\r\n  // }\r\n\r\n  if (useWebWorker && typeof Worker === 'function' && !inWebWorker) {\r\n    try {\r\n      // console.log(1)\r\n      // \"compressOnWebWorker\" is kind of like a recursion to call \"imageCompression\" again inside web worker\r\n      compressedFile = await compressOnWebWorker(file, options)\r\n    } catch (e) {\r\n      // console.warn('Run compression in web worker failed:', e, ', fall back to main thread')\r\n      // console.log(1.5)\r\n      compressedFile = await compress(file, options)\r\n    }\r\n  } else {\r\n    // console.log(2)\r\n    compressedFile = await compress(file, options)\r\n  }\r\n\r\n  try {\r\n    compressedFile.name = file.name\r\n    compressedFile.lastModified = file.lastModified\r\n  } catch (e) {}\r\n\r\n  return compressedFile\r\n}\r\n\r\nimageCompression.getDataUrlFromFile = getDataUrlFromFile\r\nimageCompression.getFilefromDataUrl = getFilefromDataUrl\r\nimageCompression.loadImage = loadImage\r\nimageCompression.drawImageInCanvas = drawImageInCanvas\r\nimageCompression.drawFileInCanvas = drawFileInCanvas\r\nimageCompression.canvasToFile = canvasToFile\r\nimageCompression.getExifOrientation = getExifOrientation\r\n\r\nimageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight\r\nimageCompression.followExifOrientation = followExifOrientation\r\nimageCompression.cleanupCanvasMemory = cleanupCanvasMemory\r\nimageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser\r\nimageCompression.version = '1.0.14'\r\n\r\nexport default imageCompression\r\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _createSvgIcon = _interopRequireDefault(require(\"./utils/createSvgIcon\"));\n\nvar _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement(\"path\", {\n  d: \"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z\"\n}), 'InsertPhoto');\n\nexports.default = _default;"],"sourceRoot":""}